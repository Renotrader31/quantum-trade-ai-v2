{"ast":null,"code":"/**\n * Advanced Machine Learning Trading System\n * Self-improving algorithm that learns from every trade and strategy\n */\n\nconst isBrowser = typeof window !== 'undefined';\nclass MLTradingSystem {\n  constructor() {\n    this.model = {\n      version: '2.0',\n      accuracy: 0.65,\n      // Starting accuracy\n      confidence: 0.5,\n      trainingData: [],\n      patterns: new Map(),\n      strategies: new Map(),\n      performance: new Map()\n    };\n    this.features = {\n      technical: ['rsi', 'macd', 'bollinger', 'vwap', 'ema', 'sma'],\n      sentiment: ['social', 'news', 'options_flow'],\n      market: ['volume', 'volatility', 'trend', 'momentum']\n    };\n    this.tradeHistory = [];\n    this.activeTrades = [];\n    this.recommendations = [];\n    this.loadModel();\n    this.initializeNeuralNetwork();\n  }\n\n  /**\n   * Initialize a simple neural network for pattern recognition\n   */\n  initializeNeuralNetwork() {\n    this.network = {\n      inputLayer: 15,\n      // Number of input features\n      hiddenLayers: [30, 20, 10],\n      // 3 hidden layers\n      outputLayer: 5,\n      // Buy strong, buy, hold, sell, sell strong\n      weights: this.initializeWeights(),\n      learningRate: 0.01\n    };\n  }\n  initializeWeights() {\n    // Initialize random weights for the neural network\n    const weights = {};\n\n    // Input to first hidden layer\n    weights.ih = Array(30).fill(0).map(() => Array(15).fill(0).map(() => Math.random() - 0.5));\n\n    // Hidden layers\n    weights.hh1 = Array(20).fill(0).map(() => Array(30).fill(0).map(() => Math.random() - 0.5));\n    weights.hh2 = Array(10).fill(0).map(() => Array(20).fill(0).map(() => Math.random() - 0.5));\n\n    // Hidden to output\n    weights.ho = Array(5).fill(0).map(() => Array(10).fill(0).map(() => Math.random() - 0.5));\n    return weights;\n  }\n\n  /**\n   * Load saved model from storage\n   */\n  loadModel() {\n    if (!isBrowser) return;\n    const savedModel = localStorage.getItem('mlTradingModel');\n    if (savedModel) {\n      try {\n        const parsed = JSON.parse(savedModel);\n        this.model = {\n          ...this.model,\n          ...parsed\n        };\n\n        // Convert arrays back to Maps\n        if (parsed.patterns) {\n          this.model.patterns = new Map(parsed.patterns);\n        }\n        if (parsed.strategies) {\n          this.model.strategies = new Map(parsed.strategies);\n        }\n        if (parsed.performance) {\n          this.model.performance = new Map(parsed.performance);\n        }\n        console.log('ML Model loaded. Accuracy:', this.model.accuracy);\n      } catch (e) {\n        console.log('Starting fresh ML model');\n      }\n    }\n    const savedHistory = localStorage.getItem('mlTradeHistory');\n    if (savedHistory) {\n      this.tradeHistory = JSON.parse(savedHistory);\n    }\n  }\n\n  /**\n   * Save model to storage\n   */\n  saveModel() {\n    if (!isBrowser) return;\n    const modelToSave = {\n      ...this.model,\n      patterns: Array.from(this.model.patterns.entries()),\n      strategies: Array.from(this.model.strategies.entries()),\n      performance: Array.from(this.model.performance.entries())\n    };\n    localStorage.setItem('mlTradingModel', JSON.stringify(modelToSave));\n    localStorage.setItem('mlTradeHistory', JSON.stringify(this.tradeHistory));\n  }\n\n  /**\n   * Extract features from market data\n   */\n  extractFeatures(data) {\n    const features = [];\n\n    // Technical indicators\n    features.push(this.calculateRSI(data.prices));\n    features.push(this.calculateMACD(data.prices));\n    features.push(this.calculateBollingerBands(data.prices));\n    features.push(data.vwap || 0);\n\n    // Volume and volatility\n    features.push(this.normalizeVolume(data.volume));\n    features.push(this.calculateVolatility(data.prices));\n\n    // Trend indicators\n    features.push(this.calculateTrend(data.prices));\n    features.push(this.calculateMomentum(data.prices));\n\n    // Options flow\n    features.push(data.callVolume / (data.putVolume || 1)); // Call/Put ratio\n    features.push(data.unusualActivity ? 1 : 0);\n\n    // Sentiment scores\n    features.push(data.socialSentiment || 0);\n    features.push(data.newsSentiment || 0);\n\n    // Market conditions\n    features.push(data.marketCap || 0);\n    features.push(data.sectorStrength || 0);\n    features.push(data.correlationSPY || 0);\n    return features.map(f => isNaN(f) ? 0 : f); // Handle NaN values\n  }\n\n  /**\n   * Forward propagation through the neural network\n   */\n  predict(features) {\n    let current = features;\n    const {\n      weights\n    } = this.network;\n\n    // Input to hidden layer 1\n    current = this.activate(this.matrixMultiply(current, weights.ih));\n\n    // Hidden layer 1 to 2\n    current = this.activate(this.matrixMultiply(current, weights.hh1));\n\n    // Hidden layer 2 to 3\n    current = this.activate(this.matrixMultiply(current, weights.hh2));\n\n    // Hidden layer 3 to output\n    const output = this.softmax(this.matrixMultiply(current, weights.ho));\n    return {\n      buyStrong: output[0],\n      buy: output[1],\n      hold: output[2],\n      sell: output[3],\n      sellStrong: output[4],\n      confidence: Math.max(...output)\n    };\n  }\n\n  /**\n   * Train the model with new data\n   */\n  async train(tradeData) {\n    const features = this.extractFeatures(tradeData.marketData);\n    const actualOutcome = this.encodeOutcome(tradeData.result);\n\n    // Store training data\n    this.model.trainingData.push({\n      features,\n      outcome: actualOutcome,\n      timestamp: Date.now(),\n      symbol: tradeData.symbol,\n      strategy: tradeData.strategy\n    });\n\n    // Keep only recent data (last 10,000 trades)\n    if (this.model.trainingData.length > 10000) {\n      this.model.trainingData = this.model.trainingData.slice(-10000);\n    }\n\n    // Backpropagation\n    await this.backpropagate(features, actualOutcome);\n\n    // Update patterns\n    this.updatePatterns(tradeData);\n\n    // Update strategy performance\n    this.updateStrategyPerformance(tradeData);\n\n    // Recalculate model accuracy\n    this.updateModelAccuracy();\n\n    // Save the updated model\n    this.saveModel();\n    return {\n      accuracy: this.model.accuracy,\n      confidence: this.model.confidence,\n      totalTrades: this.model.trainingData.length\n    };\n  }\n\n  /**\n   * Backpropagation for neural network training\n   */\n  async backpropagate(features, target) {\n    const prediction = this.predict(features);\n    const error = this.calculateError(prediction, target);\n\n    // Update weights based on error (simplified)\n    const {\n      weights,\n      learningRate\n    } = this.network;\n\n    // This is a simplified version - real implementation would be more complex\n    Object.keys(weights).forEach(layer => {\n      weights[layer] = weights[layer].map(row => row.map(w => w - learningRate * error * Math.random()));\n    });\n    this.network.weights = weights;\n  }\n\n  /**\n   * Identify and learn patterns\n   */\n  updatePatterns(tradeData) {\n    const pattern = this.identifyPattern(tradeData.marketData);\n    if (!this.model.patterns.has(pattern.type)) {\n      this.model.patterns.set(pattern.type, {\n        occurrences: 0,\n        successRate: 0,\n        totalReturn: 0\n      });\n    }\n    const patternStats = this.model.patterns.get(pattern.type);\n    patternStats.occurrences++;\n    if (tradeData.result.profit > 0) {\n      patternStats.successRate = (patternStats.successRate * (patternStats.occurrences - 1) + 1) / patternStats.occurrences;\n    } else {\n      patternStats.successRate = patternStats.successRate * (patternStats.occurrences - 1) / patternStats.occurrences;\n    }\n    patternStats.totalReturn += tradeData.result.percentReturn;\n    this.model.patterns.set(pattern.type, patternStats);\n  }\n\n  /**\n   * Identify market patterns\n   */\n  identifyPattern(marketData) {\n    const patterns = [];\n\n    // Bullish patterns\n    if (this.isGoldenCross(marketData)) patterns.push('golden_cross');\n    if (this.isBullFlag(marketData)) patterns.push('bull_flag');\n    if (this.isCupAndHandle(marketData)) patterns.push('cup_handle');\n\n    // Bearish patterns\n    if (this.isDeathCross(marketData)) patterns.push('death_cross');\n    if (this.isBearFlag(marketData)) patterns.push('bear_flag');\n    if (this.isHeadAndShoulders(marketData)) patterns.push('head_shoulders');\n\n    // Neutral patterns\n    if (this.isTriangle(marketData)) patterns.push('triangle');\n    if (this.isRange(marketData)) patterns.push('range_bound');\n    return {\n      type: patterns.join('_') || 'unknown',\n      patterns: patterns\n    };\n  }\n\n  /**\n   * Update strategy performance metrics\n   */\n  updateStrategyPerformance(tradeData) {\n    const {\n      strategy\n    } = tradeData;\n    if (!this.model.strategies.has(strategy)) {\n      this.model.strategies.set(strategy, {\n        trades: 0,\n        wins: 0,\n        losses: 0,\n        totalReturn: 0,\n        avgReturn: 0,\n        winRate: 0,\n        sharpeRatio: 0\n      });\n    }\n    const stats = this.model.strategies.get(strategy);\n    stats.trades++;\n    if (tradeData.result.profit > 0) {\n      stats.wins++;\n    } else {\n      stats.losses++;\n    }\n    stats.totalReturn += tradeData.result.percentReturn;\n    stats.avgReturn = stats.totalReturn / stats.trades;\n    stats.winRate = stats.wins / stats.trades;\n\n    // Calculate Sharpe ratio (simplified)\n    stats.sharpeRatio = this.calculateSharpeRatio(strategy);\n    this.model.strategies.set(strategy, stats);\n  }\n\n  /**\n   * Generate AI-powered recommendations\n   */\n  generateRecommendations(marketData, options = {}) {\n    const recommendations = [];\n    const symbols = options.symbols || ['SPY', 'QQQ', 'AAPL', 'NVDA', 'TSLA'];\n    symbols.forEach(symbol => {\n      const symbolData = this.getMarketData(symbol, marketData);\n      const features = this.extractFeatures(symbolData);\n      const prediction = this.predict(features);\n      const pattern = this.identifyPattern(symbolData);\n\n      // Get historical performance for this pattern\n      const patternPerformance = this.model.patterns.get(pattern.type) || {\n        successRate: 0.5,\n        occurrences: 0\n      };\n\n      // Generate recommendation\n      const action = this.determineAction(prediction);\n      if (action !== 'hold' || options.includeHold) {\n        recommendations.push({\n          symbol,\n          action,\n          confidence: prediction.confidence,\n          expectedReturn: this.calculateExpectedReturn(prediction, patternPerformance),\n          risk: this.calculateRisk(symbolData),\n          pattern: pattern.type,\n          patternSuccess: patternPerformance.successRate,\n          reasoning: this.generateReasoning(prediction, pattern, symbolData),\n          timeframe: options.timeframe || '1D',\n          entryPrice: symbolData.currentPrice,\n          stopLoss: this.calculateStopLoss(symbolData, action),\n          takeProfit: this.calculateTakeProfit(symbolData, action),\n          positionSize: this.calculatePositionSize(symbolData, options.capital || 10000)\n        });\n      }\n    });\n\n    // Sort by confidence and expected return\n    recommendations.sort((a, b) => b.confidence * b.expectedReturn - a.confidence * a.expectedReturn);\n    return recommendations.slice(0, options.limit || 5);\n  }\n\n  /**\n   * Record actual trade for learning\n   */\n  recordTrade(trade) {\n    // Add to trade history\n    this.tradeHistory.push({\n      ...trade,\n      timestamp: Date.now(),\n      modelVersion: this.model.version,\n      modelAccuracy: this.model.accuracy\n    });\n\n    // If trade is closed, train the model\n    if (trade.status === 'closed') {\n      this.train({\n        symbol: trade.symbol,\n        strategy: trade.strategy,\n        marketData: trade.entryMarketData,\n        result: {\n          profit: trade.profit,\n          percentReturn: trade.percentReturn,\n          holdingPeriod: trade.exitTime - trade.entryTime\n        }\n      });\n    }\n\n    // Update active trades\n    if (trade.status === 'open') {\n      this.activeTrades.push(trade);\n    } else {\n      this.activeTrades = this.activeTrades.filter(t => t.id !== trade.id);\n    }\n    this.saveModel();\n  }\n\n  /**\n   * Get performance metrics\n   */\n  getPerformanceMetrics() {\n    const metrics = {\n      modelAccuracy: this.model.accuracy,\n      modelConfidence: this.model.confidence,\n      totalTrades: this.tradeHistory.length,\n      winRate: this.calculateWinRate(),\n      avgReturn: this.calculateAvgReturn(),\n      sharpeRatio: this.calculateOverallSharpe(),\n      maxDrawdown: this.calculateMaxDrawdown(),\n      profitFactor: this.calculateProfitFactor(),\n      strategies: Array.from(this.model.strategies.entries()).map(([name, stats]) => ({\n        name,\n        ...stats\n      })),\n      patterns: Array.from(this.model.patterns.entries()).sort((a, b) => b[1].successRate - a[1].successRate).slice(0, 10).map(([name, stats]) => ({\n        name,\n        ...stats\n      })),\n      recentTrades: this.tradeHistory.slice(-10),\n      activeTrades: this.activeTrades\n    };\n    return metrics;\n  }\n\n  /**\n   * Calculate technical indicators\n   */\n  calculateRSI(prices, period = 14) {\n    if (prices.length < period) return 50;\n    let gains = 0;\n    let losses = 0;\n    for (let i = 1; i < period; i++) {\n      const diff = prices[i] - prices[i - 1];\n      if (diff > 0) gains += diff;else losses -= diff;\n    }\n    const avgGain = gains / period;\n    const avgLoss = losses / period;\n    const rs = avgGain / (avgLoss || 1);\n    const rsi = 100 - 100 / (1 + rs);\n    return rsi;\n  }\n  calculateMACD(prices) {\n    const ema12 = this.calculateEMA(prices, 12);\n    const ema26 = this.calculateEMA(prices, 26);\n    return ema12 - ema26;\n  }\n  calculateEMA(prices, period) {\n    if (prices.length === 0) return 0;\n    const multiplier = 2 / (period + 1);\n    let ema = prices[0];\n    for (let i = 1; i < prices.length; i++) {\n      ema = (prices[i] - ema) * multiplier + ema;\n    }\n    return ema;\n  }\n  calculateBollingerBands(prices, period = 20) {\n    const sma = prices.slice(-period).reduce((a, b) => a + b, 0) / period;\n    const variance = prices.slice(-period).reduce((sum, price) => sum + Math.pow(price - sma, 2), 0) / period;\n    const stdDev = Math.sqrt(variance);\n    const current = prices[prices.length - 1];\n    const position = (current - sma) / (stdDev * 2); // Position within bands\n\n    return position; // -1 to 1, where -1 is lower band, 1 is upper band\n  }\n  calculateVolatility(prices) {\n    if (prices.length < 2) return 0;\n    const returns = [];\n    for (let i = 1; i < prices.length; i++) {\n      returns.push((prices[i] - prices[i - 1]) / prices[i - 1]);\n    }\n    const avgReturn = returns.reduce((a, b) => a + b, 0) / returns.length;\n    const variance = returns.reduce((sum, ret) => sum + Math.pow(ret - avgReturn, 2), 0) / returns.length;\n    return Math.sqrt(variance * 252); // Annualized volatility\n  }\n  calculateTrend(prices) {\n    if (prices.length < 2) return 0;\n\n    // Simple linear regression\n    const n = prices.length;\n    const indices = Array.from({\n      length: n\n    }, (_, i) => i);\n    const sumX = indices.reduce((a, b) => a + b, 0);\n    const sumY = prices.reduce((a, b) => a + b, 0);\n    const sumXY = indices.reduce((sum, x, i) => sum + x * prices[i], 0);\n    const sumX2 = indices.reduce((sum, x) => sum + x * x, 0);\n    const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);\n    return slope; // Positive = uptrend, negative = downtrend\n  }\n  calculateMomentum(prices, period = 10) {\n    if (prices.length < period) return 0;\n    const current = prices[prices.length - 1];\n    const past = prices[prices.length - period];\n    return (current - past) / past;\n  }\n\n  /**\n   * Pattern detection methods\n   */\n  isGoldenCross(data) {\n    const sma50 = this.calculateSMA(data.prices, 50);\n    const sma200 = this.calculateSMA(data.prices, 200);\n    const prevSma50 = this.calculateSMA(data.prices.slice(0, -1), 50);\n    const prevSma200 = this.calculateSMA(data.prices.slice(0, -1), 200);\n    return prevSma50 <= prevSma200 && sma50 > sma200;\n  }\n  isDeathCross(data) {\n    const sma50 = this.calculateSMA(data.prices, 50);\n    const sma200 = this.calculateSMA(data.prices, 200);\n    const prevSma50 = this.calculateSMA(data.prices.slice(0, -1), 50);\n    const prevSma200 = this.calculateSMA(data.prices.slice(0, -1), 200);\n    return prevSma50 >= prevSma200 && sma50 < sma200;\n  }\n  isBullFlag(data) {\n    // Simplified bull flag detection\n    const recent = data.prices.slice(-20);\n    const trend = this.calculateTrend(recent);\n    const consolidation = this.calculateVolatility(recent.slice(-5));\n    return trend > 0.02 && consolidation < 0.1;\n  }\n  isBearFlag(data) {\n    const recent = data.prices.slice(-20);\n    const trend = this.calculateTrend(recent);\n    const consolidation = this.calculateVolatility(recent.slice(-5));\n    return trend < -0.02 && consolidation < 0.1;\n  }\n  isCupAndHandle(data) {\n    // Simplified cup and handle detection\n    if (data.prices.length < 50) return false;\n    const prices = data.prices.slice(-50);\n    const midPoint = Math.floor(prices.length / 2);\n    const leftHigh = Math.max(...prices.slice(0, midPoint));\n    const bottom = Math.min(...prices.slice(midPoint - 10, midPoint + 10));\n    const rightHigh = Math.max(...prices.slice(midPoint));\n    return Math.abs(leftHigh - rightHigh) / leftHigh < 0.05 && (leftHigh - bottom) / leftHigh > 0.1;\n  }\n  isHeadAndShoulders(data) {\n    // Simplified head and shoulders detection\n    if (data.prices.length < 30) return false;\n    const prices = data.prices.slice(-30);\n    const third = Math.floor(prices.length / 3);\n    const leftShoulder = Math.max(...prices.slice(0, third));\n    const head = Math.max(...prices.slice(third, third * 2));\n    const rightShoulder = Math.max(...prices.slice(third * 2));\n    return head > leftShoulder && head > rightShoulder && Math.abs(leftShoulder - rightShoulder) / leftShoulder < 0.05;\n  }\n  isTriangle(data) {\n    // Simplified triangle pattern detection\n    const highs = [];\n    const lows = [];\n    const period = 5;\n    for (let i = 0; i < data.prices.length - period; i += period) {\n      const slice = data.prices.slice(i, i + period);\n      highs.push(Math.max(...slice));\n      lows.push(Math.min(...slice));\n    }\n    const highTrend = this.calculateTrend(highs);\n    const lowTrend = this.calculateTrend(lows);\n    return Math.abs(highTrend) < 0.01 && lowTrend > 0.01;\n  }\n  isRange(data) {\n    const volatility = this.calculateVolatility(data.prices);\n    const trend = Math.abs(this.calculateTrend(data.prices));\n    return volatility < 0.15 && trend < 0.001;\n  }\n\n  /**\n   * Helper methods\n   */\n  calculateSMA(prices, period) {\n    if (prices.length < period) return prices[prices.length - 1] || 0;\n    return prices.slice(-period).reduce((a, b) => a + b, 0) / period;\n  }\n  normalizeVolume(volume) {\n    // Normalize volume to 0-1 scale\n    const avgVolume = 10000000; // 10M average\n    return Math.min(volume / avgVolume, 2);\n  }\n  activate(x) {\n    // ReLU activation\n    return Array.isArray(x) ? x.map(v => Math.max(0, v)) : Math.max(0, x);\n  }\n  softmax(x) {\n    const max = Math.max(...x);\n    const exp = x.map(v => Math.exp(v - max));\n    const sum = exp.reduce((a, b) => a + b, 0);\n    return exp.map(v => v / sum);\n  }\n  matrixMultiply(vector, matrix) {\n    return matrix.map(row => row.reduce((sum, val, i) => sum + val * (vector[i] || 0), 0));\n  }\n  calculateError(prediction, target) {\n    const predArray = [prediction.buyStrong, prediction.buy, prediction.hold, prediction.sell, prediction.sellStrong];\n    return predArray.reduce((sum, val, i) => sum + Math.pow(val - (target[i] || 0), 2), 0);\n  }\n  encodeOutcome(result) {\n    // Encode trading outcome to neural network output format\n    const returnPercent = result.percentReturn;\n    if (returnPercent > 10) return [1, 0, 0, 0, 0]; // Buy Strong\n    if (returnPercent > 3) return [0, 1, 0, 0, 0]; // Buy\n    if (returnPercent > -3) return [0, 0, 1, 0, 0]; // Hold\n    if (returnPercent > -10) return [0, 0, 0, 1, 0]; // Sell\n    return [0, 0, 0, 0, 1]; // Sell Strong\n  }\n  determineAction(prediction) {\n    const actions = ['buyStrong', 'buy', 'hold', 'sell', 'sellStrong'];\n    const values = [prediction.buyStrong, prediction.buy, prediction.hold, prediction.sell, prediction.sellStrong];\n    const maxIndex = values.indexOf(Math.max(...values));\n    return actions[maxIndex];\n  }\n  calculateExpectedReturn(prediction, patternPerformance) {\n    const baseReturn = prediction.buyStrong * 15 + prediction.buy * 7 + prediction.hold * 0 + prediction.sell * -7 + prediction.sellStrong * -15;\n\n    // Adjust based on pattern performance\n    const patternAdjustment = (patternPerformance.successRate - 0.5) * 10;\n    return baseReturn + patternAdjustment;\n  }\n  calculateRisk(data) {\n    const volatility = this.calculateVolatility(data.prices);\n    const atr = this.calculateATR(data);\n    return Math.min(volatility * atr, 1);\n  }\n  calculateATR(data, period = 14) {\n    // Average True Range calculation\n    if (!data.highs || !data.lows || data.highs.length < period) {\n      return 0.02; // Default 2%\n    }\n    const trueRanges = [];\n    for (let i = 1; i < data.highs.length; i++) {\n      const high = data.highs[i];\n      const low = data.lows[i];\n      const prevClose = data.prices[i - 1];\n      const tr = Math.max(high - low, Math.abs(high - prevClose), Math.abs(low - prevClose));\n      trueRanges.push(tr);\n    }\n    const atr = trueRanges.slice(-period).reduce((a, b) => a + b, 0) / period;\n    return atr / data.prices[data.prices.length - 1];\n  }\n  calculateStopLoss(data, action) {\n    const atr = this.calculateATR(data);\n    const currentPrice = data.currentPrice;\n    if (action.includes('buy')) {\n      return currentPrice * (1 - atr * 2);\n    } else if (action.includes('sell')) {\n      return currentPrice * (1 + atr * 2);\n    }\n    return currentPrice;\n  }\n  calculateTakeProfit(data, action) {\n    const atr = this.calculateATR(data);\n    const currentPrice = data.currentPrice;\n    if (action.includes('buy')) {\n      return currentPrice * (1 + atr * 3);\n    } else if (action.includes('sell')) {\n      return currentPrice * (1 - atr * 3);\n    }\n    return currentPrice;\n  }\n  calculatePositionSize(data, capital) {\n    const risk = this.calculateRisk(data);\n    const maxRisk = 0.02; // Max 2% risk per trade\n\n    const positionSize = capital * maxRisk / risk;\n    return Math.min(positionSize, capital * 0.25); // Max 25% per position\n  }\n  generateReasoning(prediction, pattern, data) {\n    const reasons = [];\n\n    // Add prediction reasoning\n    if (prediction.buyStrong > 0.5) {\n      reasons.push('Strong bullish signals detected');\n    } else if (prediction.buy > 0.5) {\n      reasons.push('Moderate bullish signals present');\n    } else if (prediction.sell > 0.5) {\n      reasons.push('Bearish indicators dominating');\n    }\n\n    // Add pattern reasoning\n    if (pattern.patterns.length > 0) {\n      reasons.push(`Pattern detected: ${pattern.patterns.join(', ')}`);\n    }\n\n    // Add technical reasoning\n    const rsi = this.calculateRSI(data.prices);\n    if (rsi < 30) reasons.push('RSI indicates oversold conditions');\n    if (rsi > 70) reasons.push('RSI indicates overbought conditions');\n\n    // Add volume reasoning\n    if (data.volume > data.avgVolume * 1.5) {\n      reasons.push('Unusual volume detected');\n    }\n\n    // Add confidence reasoning\n    reasons.push(`Model confidence: ${(prediction.confidence * 100).toFixed(1)}%`);\n    return reasons.join('. ');\n  }\n  updateModelAccuracy() {\n    if (this.tradeHistory.length < 10) return;\n    const recentTrades = this.tradeHistory.slice(-100);\n    const correctPredictions = recentTrades.filter(trade => trade.prediction === 'buy' && trade.result && trade.result.profit > 0 || trade.prediction === 'sell' && trade.result && trade.result.profit > 0 || trade.prediction === 'hold' && trade.result && Math.abs(trade.result.percentReturn) < 2).length;\n    this.model.accuracy = correctPredictions / recentTrades.length;\n    this.model.confidence = Math.min(this.model.accuracy * 1.2, 1);\n  }\n  calculateWinRate() {\n    if (this.tradeHistory.length === 0) return 0;\n    const wins = this.tradeHistory.filter(t => t.result && t.result.profit > 0).length;\n    return wins / this.tradeHistory.length;\n  }\n  calculateAvgReturn() {\n    if (this.tradeHistory.length === 0) return 0;\n    const totalReturn = this.tradeHistory.reduce((sum, trade) => {\n      var _trade$result;\n      return sum + (((_trade$result = trade.result) === null || _trade$result === void 0 ? void 0 : _trade$result.percentReturn) || 0);\n    }, 0);\n    return totalReturn / this.tradeHistory.length;\n  }\n  calculateOverallSharpe() {\n    if (this.tradeHistory.length < 2) return 0;\n    const returns = this.tradeHistory.map(t => {\n      var _t$result;\n      return ((_t$result = t.result) === null || _t$result === void 0 ? void 0 : _t$result.percentReturn) || 0;\n    });\n    const avgReturn = returns.reduce((a, b) => a + b, 0) / returns.length;\n    const variance = returns.reduce((sum, ret) => sum + Math.pow(ret - avgReturn, 2), 0) / returns.length;\n    const stdDev = Math.sqrt(variance);\n    return stdDev === 0 ? 0 : (avgReturn - 0.02) / stdDev; // 2% risk-free rate\n  }\n  calculateSharpeRatio(strategy) {\n    const trades = this.tradeHistory.filter(t => t.strategy === strategy);\n    if (trades.length < 2) return 0;\n    const returns = trades.map(t => {\n      var _t$result2;\n      return ((_t$result2 = t.result) === null || _t$result2 === void 0 ? void 0 : _t$result2.percentReturn) || 0;\n    });\n    const avgReturn = returns.reduce((a, b) => a + b, 0) / returns.length;\n    const variance = returns.reduce((sum, ret) => sum + Math.pow(ret - avgReturn, 2), 0) / returns.length;\n    const stdDev = Math.sqrt(variance);\n    return stdDev === 0 ? 0 : (avgReturn - 0.02) / stdDev;\n  }\n  calculateMaxDrawdown() {\n    if (this.tradeHistory.length === 0) return 0;\n    let peak = 0;\n    let maxDrawdown = 0;\n    let runningTotal = 0;\n    this.tradeHistory.forEach(trade => {\n      var _trade$result2;\n      runningTotal += ((_trade$result2 = trade.result) === null || _trade$result2 === void 0 ? void 0 : _trade$result2.profit) || 0;\n      if (runningTotal > peak) {\n        peak = runningTotal;\n      }\n      const drawdown = (peak - runningTotal) / peak;\n      if (drawdown > maxDrawdown) {\n        maxDrawdown = drawdown;\n      }\n    });\n    return maxDrawdown;\n  }\n  calculateProfitFactor() {\n    const wins = this.tradeHistory.filter(t => t.result && t.result.profit > 0).reduce((sum, t) => sum + t.result.profit, 0);\n    const losses = Math.abs(this.tradeHistory.filter(t => t.result && t.result.profit < 0).reduce((sum, t) => sum + t.result.profit, 0));\n    return losses === 0 ? wins : wins / losses;\n  }\n  getMarketData(symbol, marketData) {\n    // Extract symbol-specific data from market data\n    return marketData[symbol] || {\n      symbol,\n      prices: [],\n      volume: 0,\n      currentPrice: 0,\n      highs: [],\n      lows: [],\n      vwap: 0,\n      callVolume: 0,\n      putVolume: 0,\n      unusualActivity: false,\n      socialSentiment: 0,\n      newsSentiment: 0,\n      marketCap: 0,\n      sectorStrength: 0,\n      correlationSPY: 0,\n      avgVolume: 0\n    };\n  }\n}\n\n// Export for use in React components\nexport default MLTradingSystem;","map":{"version":3,"names":["isBrowser","window","MLTradingSystem","constructor","model","version","accuracy","confidence","trainingData","patterns","Map","strategies","performance","features","technical","sentiment","market","tradeHistory","activeTrades","recommendations","loadModel","initializeNeuralNetwork","network","inputLayer","hiddenLayers","outputLayer","weights","initializeWeights","learningRate","ih","Array","fill","map","Math","random","hh1","hh2","ho","savedModel","localStorage","getItem","parsed","JSON","parse","console","log","e","savedHistory","saveModel","modelToSave","from","entries","setItem","stringify","extractFeatures","data","push","calculateRSI","prices","calculateMACD","calculateBollingerBands","vwap","normalizeVolume","volume","calculateVolatility","calculateTrend","calculateMomentum","callVolume","putVolume","unusualActivity","socialSentiment","newsSentiment","marketCap","sectorStrength","correlationSPY","f","isNaN","predict","current","activate","matrixMultiply","output","softmax","buyStrong","buy","hold","sell","sellStrong","max","train","tradeData","marketData","actualOutcome","encodeOutcome","result","outcome","timestamp","Date","now","symbol","strategy","length","slice","backpropagate","updatePatterns","updateStrategyPerformance","updateModelAccuracy","totalTrades","target","prediction","error","calculateError","Object","keys","forEach","layer","row","w","pattern","identifyPattern","has","type","set","occurrences","successRate","totalReturn","patternStats","get","profit","percentReturn","isGoldenCross","isBullFlag","isCupAndHandle","isDeathCross","isBearFlag","isHeadAndShoulders","isTriangle","isRange","join","trades","wins","losses","avgReturn","winRate","sharpeRatio","stats","calculateSharpeRatio","generateRecommendations","options","symbols","symbolData","getMarketData","patternPerformance","action","determineAction","includeHold","expectedReturn","calculateExpectedReturn","risk","calculateRisk","patternSuccess","reasoning","generateReasoning","timeframe","entryPrice","currentPrice","stopLoss","calculateStopLoss","takeProfit","calculateTakeProfit","positionSize","calculatePositionSize","capital","sort","a","b","limit","recordTrade","trade","modelVersion","modelAccuracy","status","entryMarketData","holdingPeriod","exitTime","entryTime","filter","t","id","getPerformanceMetrics","metrics","modelConfidence","calculateWinRate","calculateAvgReturn","calculateOverallSharpe","maxDrawdown","calculateMaxDrawdown","profitFactor","calculateProfitFactor","name","recentTrades","period","gains","i","diff","avgGain","avgLoss","rs","rsi","ema12","calculateEMA","ema26","multiplier","ema","sma","reduce","variance","sum","price","pow","stdDev","sqrt","position","returns","ret","n","indices","_","sumX","sumY","sumXY","x","sumX2","slope","past","sma50","calculateSMA","sma200","prevSma50","prevSma200","recent","trend","consolidation","midPoint","floor","leftHigh","bottom","min","rightHigh","abs","third","leftShoulder","head","rightShoulder","highs","lows","highTrend","lowTrend","volatility","avgVolume","isArray","v","exp","vector","matrix","val","predArray","returnPercent","actions","values","maxIndex","indexOf","baseReturn","patternAdjustment","atr","calculateATR","trueRanges","high","low","prevClose","tr","includes","maxRisk","reasons","toFixed","correctPredictions","_trade$result","_t$result","_t$result2","peak","runningTotal","_trade$result2","drawdown"],"sources":["/home/user/webapp/src/services/MLTradingSystem.js"],"sourcesContent":["/**\n * Advanced Machine Learning Trading System\n * Self-improving algorithm that learns from every trade and strategy\n */\n\nconst isBrowser = typeof window !== 'undefined';\n\nclass MLTradingSystem {\n    constructor() {\n        this.model = {\n            version: '2.0',\n            accuracy: 0.65, // Starting accuracy\n            confidence: 0.5,\n            trainingData: [],\n            patterns: new Map(),\n            strategies: new Map(),\n            performance: new Map()\n        };\n        \n        this.features = {\n            technical: ['rsi', 'macd', 'bollinger', 'vwap', 'ema', 'sma'],\n            sentiment: ['social', 'news', 'options_flow'],\n            market: ['volume', 'volatility', 'trend', 'momentum']\n        };\n        \n        this.tradeHistory = [];\n        this.activeTrades = [];\n        this.recommendations = [];\n        \n        this.loadModel();\n        this.initializeNeuralNetwork();\n    }\n\n    /**\n     * Initialize a simple neural network for pattern recognition\n     */\n    initializeNeuralNetwork() {\n        this.network = {\n            inputLayer: 15, // Number of input features\n            hiddenLayers: [30, 20, 10], // 3 hidden layers\n            outputLayer: 5, // Buy strong, buy, hold, sell, sell strong\n            weights: this.initializeWeights(),\n            learningRate: 0.01\n        };\n    }\n\n    initializeWeights() {\n        // Initialize random weights for the neural network\n        const weights = {};\n        \n        // Input to first hidden layer\n        weights.ih = Array(30).fill(0).map(() => \n            Array(15).fill(0).map(() => Math.random() - 0.5)\n        );\n        \n        // Hidden layers\n        weights.hh1 = Array(20).fill(0).map(() => \n            Array(30).fill(0).map(() => Math.random() - 0.5)\n        );\n        weights.hh2 = Array(10).fill(0).map(() => \n            Array(20).fill(0).map(() => Math.random() - 0.5)\n        );\n        \n        // Hidden to output\n        weights.ho = Array(5).fill(0).map(() => \n            Array(10).fill(0).map(() => Math.random() - 0.5)\n        );\n        \n        return weights;\n    }\n\n    /**\n     * Load saved model from storage\n     */\n    loadModel() {\n        if (!isBrowser) return;\n        \n        const savedModel = localStorage.getItem('mlTradingModel');\n        if (savedModel) {\n            try {\n                const parsed = JSON.parse(savedModel);\n                this.model = { ...this.model, ...parsed };\n                \n                // Convert arrays back to Maps\n                if (parsed.patterns) {\n                    this.model.patterns = new Map(parsed.patterns);\n                }\n                if (parsed.strategies) {\n                    this.model.strategies = new Map(parsed.strategies);\n                }\n                if (parsed.performance) {\n                    this.model.performance = new Map(parsed.performance);\n                }\n                \n                console.log('ML Model loaded. Accuracy:', this.model.accuracy);\n            } catch (e) {\n                console.log('Starting fresh ML model');\n            }\n        }\n        \n        const savedHistory = localStorage.getItem('mlTradeHistory');\n        if (savedHistory) {\n            this.tradeHistory = JSON.parse(savedHistory);\n        }\n    }\n\n    /**\n     * Save model to storage\n     */\n    saveModel() {\n        if (!isBrowser) return;\n        \n        const modelToSave = {\n            ...this.model,\n            patterns: Array.from(this.model.patterns.entries()),\n            strategies: Array.from(this.model.strategies.entries()),\n            performance: Array.from(this.model.performance.entries())\n        };\n        \n        localStorage.setItem('mlTradingModel', JSON.stringify(modelToSave));\n        localStorage.setItem('mlTradeHistory', JSON.stringify(this.tradeHistory));\n    }\n\n    /**\n     * Extract features from market data\n     */\n    extractFeatures(data) {\n        const features = [];\n        \n        // Technical indicators\n        features.push(this.calculateRSI(data.prices));\n        features.push(this.calculateMACD(data.prices));\n        features.push(this.calculateBollingerBands(data.prices));\n        features.push(data.vwap || 0);\n        \n        // Volume and volatility\n        features.push(this.normalizeVolume(data.volume));\n        features.push(this.calculateVolatility(data.prices));\n        \n        // Trend indicators\n        features.push(this.calculateTrend(data.prices));\n        features.push(this.calculateMomentum(data.prices));\n        \n        // Options flow\n        features.push(data.callVolume / (data.putVolume || 1)); // Call/Put ratio\n        features.push(data.unusualActivity ? 1 : 0);\n        \n        // Sentiment scores\n        features.push(data.socialSentiment || 0);\n        features.push(data.newsSentiment || 0);\n        \n        // Market conditions\n        features.push(data.marketCap || 0);\n        features.push(data.sectorStrength || 0);\n        features.push(data.correlationSPY || 0);\n        \n        return features.map(f => isNaN(f) ? 0 : f); // Handle NaN values\n    }\n\n    /**\n     * Forward propagation through the neural network\n     */\n    predict(features) {\n        let current = features;\n        const { weights } = this.network;\n        \n        // Input to hidden layer 1\n        current = this.activate(this.matrixMultiply(current, weights.ih));\n        \n        // Hidden layer 1 to 2\n        current = this.activate(this.matrixMultiply(current, weights.hh1));\n        \n        // Hidden layer 2 to 3\n        current = this.activate(this.matrixMultiply(current, weights.hh2));\n        \n        // Hidden layer 3 to output\n        const output = this.softmax(this.matrixMultiply(current, weights.ho));\n        \n        return {\n            buyStrong: output[0],\n            buy: output[1],\n            hold: output[2],\n            sell: output[3],\n            sellStrong: output[4],\n            confidence: Math.max(...output)\n        };\n    }\n\n    /**\n     * Train the model with new data\n     */\n    async train(tradeData) {\n        const features = this.extractFeatures(tradeData.marketData);\n        const actualOutcome = this.encodeOutcome(tradeData.result);\n        \n        // Store training data\n        this.model.trainingData.push({\n            features,\n            outcome: actualOutcome,\n            timestamp: Date.now(),\n            symbol: tradeData.symbol,\n            strategy: tradeData.strategy\n        });\n        \n        // Keep only recent data (last 10,000 trades)\n        if (this.model.trainingData.length > 10000) {\n            this.model.trainingData = this.model.trainingData.slice(-10000);\n        }\n        \n        // Backpropagation\n        await this.backpropagate(features, actualOutcome);\n        \n        // Update patterns\n        this.updatePatterns(tradeData);\n        \n        // Update strategy performance\n        this.updateStrategyPerformance(tradeData);\n        \n        // Recalculate model accuracy\n        this.updateModelAccuracy();\n        \n        // Save the updated model\n        this.saveModel();\n        \n        return {\n            accuracy: this.model.accuracy,\n            confidence: this.model.confidence,\n            totalTrades: this.model.trainingData.length\n        };\n    }\n\n    /**\n     * Backpropagation for neural network training\n     */\n    async backpropagate(features, target) {\n        const prediction = this.predict(features);\n        const error = this.calculateError(prediction, target);\n        \n        // Update weights based on error (simplified)\n        const { weights, learningRate } = this.network;\n        \n        // This is a simplified version - real implementation would be more complex\n        Object.keys(weights).forEach(layer => {\n            weights[layer] = weights[layer].map(row =>\n                row.map(w => w - learningRate * error * Math.random())\n            );\n        });\n        \n        this.network.weights = weights;\n    }\n\n    /**\n     * Identify and learn patterns\n     */\n    updatePatterns(tradeData) {\n        const pattern = this.identifyPattern(tradeData.marketData);\n        \n        if (!this.model.patterns.has(pattern.type)) {\n            this.model.patterns.set(pattern.type, {\n                occurrences: 0,\n                successRate: 0,\n                totalReturn: 0\n            });\n        }\n        \n        const patternStats = this.model.patterns.get(pattern.type);\n        patternStats.occurrences++;\n        \n        if (tradeData.result.profit > 0) {\n            patternStats.successRate = \n                (patternStats.successRate * (patternStats.occurrences - 1) + 1) / \n                patternStats.occurrences;\n        } else {\n            patternStats.successRate = \n                (patternStats.successRate * (patternStats.occurrences - 1)) / \n                patternStats.occurrences;\n        }\n        \n        patternStats.totalReturn += tradeData.result.percentReturn;\n        \n        this.model.patterns.set(pattern.type, patternStats);\n    }\n\n    /**\n     * Identify market patterns\n     */\n    identifyPattern(marketData) {\n        const patterns = [];\n        \n        // Bullish patterns\n        if (this.isGoldenCross(marketData)) patterns.push('golden_cross');\n        if (this.isBullFlag(marketData)) patterns.push('bull_flag');\n        if (this.isCupAndHandle(marketData)) patterns.push('cup_handle');\n        \n        // Bearish patterns\n        if (this.isDeathCross(marketData)) patterns.push('death_cross');\n        if (this.isBearFlag(marketData)) patterns.push('bear_flag');\n        if (this.isHeadAndShoulders(marketData)) patterns.push('head_shoulders');\n        \n        // Neutral patterns\n        if (this.isTriangle(marketData)) patterns.push('triangle');\n        if (this.isRange(marketData)) patterns.push('range_bound');\n        \n        return {\n            type: patterns.join('_') || 'unknown',\n            patterns: patterns\n        };\n    }\n\n    /**\n     * Update strategy performance metrics\n     */\n    updateStrategyPerformance(tradeData) {\n        const { strategy } = tradeData;\n        \n        if (!this.model.strategies.has(strategy)) {\n            this.model.strategies.set(strategy, {\n                trades: 0,\n                wins: 0,\n                losses: 0,\n                totalReturn: 0,\n                avgReturn: 0,\n                winRate: 0,\n                sharpeRatio: 0\n            });\n        }\n        \n        const stats = this.model.strategies.get(strategy);\n        stats.trades++;\n        \n        if (tradeData.result.profit > 0) {\n            stats.wins++;\n        } else {\n            stats.losses++;\n        }\n        \n        stats.totalReturn += tradeData.result.percentReturn;\n        stats.avgReturn = stats.totalReturn / stats.trades;\n        stats.winRate = stats.wins / stats.trades;\n        \n        // Calculate Sharpe ratio (simplified)\n        stats.sharpeRatio = this.calculateSharpeRatio(strategy);\n        \n        this.model.strategies.set(strategy, stats);\n    }\n\n    /**\n     * Generate AI-powered recommendations\n     */\n    generateRecommendations(marketData, options = {}) {\n        const recommendations = [];\n        const symbols = options.symbols || ['SPY', 'QQQ', 'AAPL', 'NVDA', 'TSLA'];\n        \n        symbols.forEach(symbol => {\n            const symbolData = this.getMarketData(symbol, marketData);\n            const features = this.extractFeatures(symbolData);\n            const prediction = this.predict(features);\n            const pattern = this.identifyPattern(symbolData);\n            \n            // Get historical performance for this pattern\n            const patternPerformance = this.model.patterns.get(pattern.type) || {\n                successRate: 0.5,\n                occurrences: 0\n            };\n            \n            // Generate recommendation\n            const action = this.determineAction(prediction);\n            \n            if (action !== 'hold' || options.includeHold) {\n                recommendations.push({\n                    symbol,\n                    action,\n                    confidence: prediction.confidence,\n                    expectedReturn: this.calculateExpectedReturn(prediction, patternPerformance),\n                    risk: this.calculateRisk(symbolData),\n                    pattern: pattern.type,\n                    patternSuccess: patternPerformance.successRate,\n                    reasoning: this.generateReasoning(prediction, pattern, symbolData),\n                    timeframe: options.timeframe || '1D',\n                    entryPrice: symbolData.currentPrice,\n                    stopLoss: this.calculateStopLoss(symbolData, action),\n                    takeProfit: this.calculateTakeProfit(symbolData, action),\n                    positionSize: this.calculatePositionSize(symbolData, options.capital || 10000)\n                });\n            }\n        });\n        \n        // Sort by confidence and expected return\n        recommendations.sort((a, b) => \n            (b.confidence * b.expectedReturn) - (a.confidence * a.expectedReturn)\n        );\n        \n        return recommendations.slice(0, options.limit || 5);\n    }\n\n    /**\n     * Record actual trade for learning\n     */\n    recordTrade(trade) {\n        // Add to trade history\n        this.tradeHistory.push({\n            ...trade,\n            timestamp: Date.now(),\n            modelVersion: this.model.version,\n            modelAccuracy: this.model.accuracy\n        });\n        \n        // If trade is closed, train the model\n        if (trade.status === 'closed') {\n            this.train({\n                symbol: trade.symbol,\n                strategy: trade.strategy,\n                marketData: trade.entryMarketData,\n                result: {\n                    profit: trade.profit,\n                    percentReturn: trade.percentReturn,\n                    holdingPeriod: trade.exitTime - trade.entryTime\n                }\n            });\n        }\n        \n        // Update active trades\n        if (trade.status === 'open') {\n            this.activeTrades.push(trade);\n        } else {\n            this.activeTrades = this.activeTrades.filter(t => t.id !== trade.id);\n        }\n        \n        this.saveModel();\n    }\n\n    /**\n     * Get performance metrics\n     */\n    getPerformanceMetrics() {\n        const metrics = {\n            modelAccuracy: this.model.accuracy,\n            modelConfidence: this.model.confidence,\n            totalTrades: this.tradeHistory.length,\n            winRate: this.calculateWinRate(),\n            avgReturn: this.calculateAvgReturn(),\n            sharpeRatio: this.calculateOverallSharpe(),\n            maxDrawdown: this.calculateMaxDrawdown(),\n            profitFactor: this.calculateProfitFactor(),\n            strategies: Array.from(this.model.strategies.entries()).map(([name, stats]) => ({\n                name,\n                ...stats\n            })),\n            patterns: Array.from(this.model.patterns.entries())\n                .sort((a, b) => b[1].successRate - a[1].successRate)\n                .slice(0, 10)\n                .map(([name, stats]) => ({\n                    name,\n                    ...stats\n                })),\n            recentTrades: this.tradeHistory.slice(-10),\n            activeTrades: this.activeTrades\n        };\n        \n        return metrics;\n    }\n\n    /**\n     * Calculate technical indicators\n     */\n    calculateRSI(prices, period = 14) {\n        if (prices.length < period) return 50;\n        \n        let gains = 0;\n        let losses = 0;\n        \n        for (let i = 1; i < period; i++) {\n            const diff = prices[i] - prices[i - 1];\n            if (diff > 0) gains += diff;\n            else losses -= diff;\n        }\n        \n        const avgGain = gains / period;\n        const avgLoss = losses / period;\n        const rs = avgGain / (avgLoss || 1);\n        const rsi = 100 - (100 / (1 + rs));\n        \n        return rsi;\n    }\n\n    calculateMACD(prices) {\n        const ema12 = this.calculateEMA(prices, 12);\n        const ema26 = this.calculateEMA(prices, 26);\n        return ema12 - ema26;\n    }\n\n    calculateEMA(prices, period) {\n        if (prices.length === 0) return 0;\n        \n        const multiplier = 2 / (period + 1);\n        let ema = prices[0];\n        \n        for (let i = 1; i < prices.length; i++) {\n            ema = (prices[i] - ema) * multiplier + ema;\n        }\n        \n        return ema;\n    }\n\n    calculateBollingerBands(prices, period = 20) {\n        const sma = prices.slice(-period).reduce((a, b) => a + b, 0) / period;\n        const variance = prices.slice(-period).reduce((sum, price) => \n            sum + Math.pow(price - sma, 2), 0) / period;\n        const stdDev = Math.sqrt(variance);\n        \n        const current = prices[prices.length - 1];\n        const position = (current - sma) / (stdDev * 2); // Position within bands\n        \n        return position; // -1 to 1, where -1 is lower band, 1 is upper band\n    }\n\n    calculateVolatility(prices) {\n        if (prices.length < 2) return 0;\n        \n        const returns = [];\n        for (let i = 1; i < prices.length; i++) {\n            returns.push((prices[i] - prices[i - 1]) / prices[i - 1]);\n        }\n        \n        const avgReturn = returns.reduce((a, b) => a + b, 0) / returns.length;\n        const variance = returns.reduce((sum, ret) => \n            sum + Math.pow(ret - avgReturn, 2), 0) / returns.length;\n        \n        return Math.sqrt(variance * 252); // Annualized volatility\n    }\n\n    calculateTrend(prices) {\n        if (prices.length < 2) return 0;\n        \n        // Simple linear regression\n        const n = prices.length;\n        const indices = Array.from({ length: n }, (_, i) => i);\n        \n        const sumX = indices.reduce((a, b) => a + b, 0);\n        const sumY = prices.reduce((a, b) => a + b, 0);\n        const sumXY = indices.reduce((sum, x, i) => sum + x * prices[i], 0);\n        const sumX2 = indices.reduce((sum, x) => sum + x * x, 0);\n        \n        const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);\n        \n        return slope; // Positive = uptrend, negative = downtrend\n    }\n\n    calculateMomentum(prices, period = 10) {\n        if (prices.length < period) return 0;\n        \n        const current = prices[prices.length - 1];\n        const past = prices[prices.length - period];\n        \n        return (current - past) / past;\n    }\n\n    /**\n     * Pattern detection methods\n     */\n    isGoldenCross(data) {\n        const sma50 = this.calculateSMA(data.prices, 50);\n        const sma200 = this.calculateSMA(data.prices, 200);\n        const prevSma50 = this.calculateSMA(data.prices.slice(0, -1), 50);\n        const prevSma200 = this.calculateSMA(data.prices.slice(0, -1), 200);\n        \n        return prevSma50 <= prevSma200 && sma50 > sma200;\n    }\n\n    isDeathCross(data) {\n        const sma50 = this.calculateSMA(data.prices, 50);\n        const sma200 = this.calculateSMA(data.prices, 200);\n        const prevSma50 = this.calculateSMA(data.prices.slice(0, -1), 50);\n        const prevSma200 = this.calculateSMA(data.prices.slice(0, -1), 200);\n        \n        return prevSma50 >= prevSma200 && sma50 < sma200;\n    }\n\n    isBullFlag(data) {\n        // Simplified bull flag detection\n        const recent = data.prices.slice(-20);\n        const trend = this.calculateTrend(recent);\n        const consolidation = this.calculateVolatility(recent.slice(-5));\n        \n        return trend > 0.02 && consolidation < 0.1;\n    }\n\n    isBearFlag(data) {\n        const recent = data.prices.slice(-20);\n        const trend = this.calculateTrend(recent);\n        const consolidation = this.calculateVolatility(recent.slice(-5));\n        \n        return trend < -0.02 && consolidation < 0.1;\n    }\n\n    isCupAndHandle(data) {\n        // Simplified cup and handle detection\n        if (data.prices.length < 50) return false;\n        \n        const prices = data.prices.slice(-50);\n        const midPoint = Math.floor(prices.length / 2);\n        const leftHigh = Math.max(...prices.slice(0, midPoint));\n        const bottom = Math.min(...prices.slice(midPoint - 10, midPoint + 10));\n        const rightHigh = Math.max(...prices.slice(midPoint));\n        \n        return (\n            Math.abs(leftHigh - rightHigh) / leftHigh < 0.05 &&\n            (leftHigh - bottom) / leftHigh > 0.1\n        );\n    }\n\n    isHeadAndShoulders(data) {\n        // Simplified head and shoulders detection\n        if (data.prices.length < 30) return false;\n        \n        const prices = data.prices.slice(-30);\n        const third = Math.floor(prices.length / 3);\n        \n        const leftShoulder = Math.max(...prices.slice(0, third));\n        const head = Math.max(...prices.slice(third, third * 2));\n        const rightShoulder = Math.max(...prices.slice(third * 2));\n        \n        return (\n            head > leftShoulder &&\n            head > rightShoulder &&\n            Math.abs(leftShoulder - rightShoulder) / leftShoulder < 0.05\n        );\n    }\n\n    isTriangle(data) {\n        // Simplified triangle pattern detection\n        const highs = [];\n        const lows = [];\n        const period = 5;\n        \n        for (let i = 0; i < data.prices.length - period; i += period) {\n            const slice = data.prices.slice(i, i + period);\n            highs.push(Math.max(...slice));\n            lows.push(Math.min(...slice));\n        }\n        \n        const highTrend = this.calculateTrend(highs);\n        const lowTrend = this.calculateTrend(lows);\n        \n        return Math.abs(highTrend) < 0.01 && lowTrend > 0.01;\n    }\n\n    isRange(data) {\n        const volatility = this.calculateVolatility(data.prices);\n        const trend = Math.abs(this.calculateTrend(data.prices));\n        \n        return volatility < 0.15 && trend < 0.001;\n    }\n\n    /**\n     * Helper methods\n     */\n    calculateSMA(prices, period) {\n        if (prices.length < period) return prices[prices.length - 1] || 0;\n        return prices.slice(-period).reduce((a, b) => a + b, 0) / period;\n    }\n\n    normalizeVolume(volume) {\n        // Normalize volume to 0-1 scale\n        const avgVolume = 10000000; // 10M average\n        return Math.min(volume / avgVolume, 2);\n    }\n\n    activate(x) {\n        // ReLU activation\n        return Array.isArray(x) ? x.map(v => Math.max(0, v)) : Math.max(0, x);\n    }\n\n    softmax(x) {\n        const max = Math.max(...x);\n        const exp = x.map(v => Math.exp(v - max));\n        const sum = exp.reduce((a, b) => a + b, 0);\n        return exp.map(v => v / sum);\n    }\n\n    matrixMultiply(vector, matrix) {\n        return matrix.map(row =>\n            row.reduce((sum, val, i) => sum + val * (vector[i] || 0), 0)\n        );\n    }\n\n    calculateError(prediction, target) {\n        const predArray = [\n            prediction.buyStrong,\n            prediction.buy,\n            prediction.hold,\n            prediction.sell,\n            prediction.sellStrong\n        ];\n        \n        return predArray.reduce((sum, val, i) => \n            sum + Math.pow(val - (target[i] || 0), 2), 0\n        );\n    }\n\n    encodeOutcome(result) {\n        // Encode trading outcome to neural network output format\n        const returnPercent = result.percentReturn;\n        \n        if (returnPercent > 10) return [1, 0, 0, 0, 0]; // Buy Strong\n        if (returnPercent > 3) return [0, 1, 0, 0, 0];  // Buy\n        if (returnPercent > -3) return [0, 0, 1, 0, 0]; // Hold\n        if (returnPercent > -10) return [0, 0, 0, 1, 0]; // Sell\n        return [0, 0, 0, 0, 1]; // Sell Strong\n    }\n\n    determineAction(prediction) {\n        const actions = ['buyStrong', 'buy', 'hold', 'sell', 'sellStrong'];\n        const values = [\n            prediction.buyStrong,\n            prediction.buy,\n            prediction.hold,\n            prediction.sell,\n            prediction.sellStrong\n        ];\n        \n        const maxIndex = values.indexOf(Math.max(...values));\n        return actions[maxIndex];\n    }\n\n    calculateExpectedReturn(prediction, patternPerformance) {\n        const baseReturn = \n            prediction.buyStrong * 15 +\n            prediction.buy * 7 +\n            prediction.hold * 0 +\n            prediction.sell * -7 +\n            prediction.sellStrong * -15;\n        \n        // Adjust based on pattern performance\n        const patternAdjustment = (patternPerformance.successRate - 0.5) * 10;\n        \n        return baseReturn + patternAdjustment;\n    }\n\n    calculateRisk(data) {\n        const volatility = this.calculateVolatility(data.prices);\n        const atr = this.calculateATR(data);\n        \n        return Math.min(volatility * atr, 1);\n    }\n\n    calculateATR(data, period = 14) {\n        // Average True Range calculation\n        if (!data.highs || !data.lows || data.highs.length < period) {\n            return 0.02; // Default 2%\n        }\n        \n        const trueRanges = [];\n        for (let i = 1; i < data.highs.length; i++) {\n            const high = data.highs[i];\n            const low = data.lows[i];\n            const prevClose = data.prices[i - 1];\n            \n            const tr = Math.max(\n                high - low,\n                Math.abs(high - prevClose),\n                Math.abs(low - prevClose)\n            );\n            trueRanges.push(tr);\n        }\n        \n        const atr = trueRanges.slice(-period).reduce((a, b) => a + b, 0) / period;\n        return atr / data.prices[data.prices.length - 1];\n    }\n\n    calculateStopLoss(data, action) {\n        const atr = this.calculateATR(data);\n        const currentPrice = data.currentPrice;\n        \n        if (action.includes('buy')) {\n            return currentPrice * (1 - atr * 2);\n        } else if (action.includes('sell')) {\n            return currentPrice * (1 + atr * 2);\n        }\n        return currentPrice;\n    }\n\n    calculateTakeProfit(data, action) {\n        const atr = this.calculateATR(data);\n        const currentPrice = data.currentPrice;\n        \n        if (action.includes('buy')) {\n            return currentPrice * (1 + atr * 3);\n        } else if (action.includes('sell')) {\n            return currentPrice * (1 - atr * 3);\n        }\n        return currentPrice;\n    }\n\n    calculatePositionSize(data, capital) {\n        const risk = this.calculateRisk(data);\n        const maxRisk = 0.02; // Max 2% risk per trade\n        \n        const positionSize = (capital * maxRisk) / risk;\n        return Math.min(positionSize, capital * 0.25); // Max 25% per position\n    }\n\n    generateReasoning(prediction, pattern, data) {\n        const reasons = [];\n        \n        // Add prediction reasoning\n        if (prediction.buyStrong > 0.5) {\n            reasons.push('Strong bullish signals detected');\n        } else if (prediction.buy > 0.5) {\n            reasons.push('Moderate bullish signals present');\n        } else if (prediction.sell > 0.5) {\n            reasons.push('Bearish indicators dominating');\n        }\n        \n        // Add pattern reasoning\n        if (pattern.patterns.length > 0) {\n            reasons.push(`Pattern detected: ${pattern.patterns.join(', ')}`);\n        }\n        \n        // Add technical reasoning\n        const rsi = this.calculateRSI(data.prices);\n        if (rsi < 30) reasons.push('RSI indicates oversold conditions');\n        if (rsi > 70) reasons.push('RSI indicates overbought conditions');\n        \n        // Add volume reasoning\n        if (data.volume > data.avgVolume * 1.5) {\n            reasons.push('Unusual volume detected');\n        }\n        \n        // Add confidence reasoning\n        reasons.push(`Model confidence: ${(prediction.confidence * 100).toFixed(1)}%`);\n        \n        return reasons.join('. ');\n    }\n\n    updateModelAccuracy() {\n        if (this.tradeHistory.length < 10) return;\n        \n        const recentTrades = this.tradeHistory.slice(-100);\n        const correctPredictions = recentTrades.filter(trade => \n            (trade.prediction === 'buy' && trade.result && trade.result.profit > 0) ||\n            (trade.prediction === 'sell' && trade.result && trade.result.profit > 0) ||\n            (trade.prediction === 'hold' && trade.result && Math.abs(trade.result.percentReturn) < 2)\n        ).length;\n        \n        this.model.accuracy = correctPredictions / recentTrades.length;\n        this.model.confidence = Math.min(this.model.accuracy * 1.2, 1);\n    }\n\n    calculateWinRate() {\n        if (this.tradeHistory.length === 0) return 0;\n        \n        const wins = this.tradeHistory.filter(t => t.result && t.result.profit > 0).length;\n        return wins / this.tradeHistory.length;\n    }\n\n    calculateAvgReturn() {\n        if (this.tradeHistory.length === 0) return 0;\n        \n        const totalReturn = this.tradeHistory.reduce((sum, trade) => \n            sum + (trade.result?.percentReturn || 0), 0\n        );\n        \n        return totalReturn / this.tradeHistory.length;\n    }\n\n    calculateOverallSharpe() {\n        if (this.tradeHistory.length < 2) return 0;\n        \n        const returns = this.tradeHistory.map(t => t.result?.percentReturn || 0);\n        const avgReturn = returns.reduce((a, b) => a + b, 0) / returns.length;\n        const variance = returns.reduce((sum, ret) => \n            sum + Math.pow(ret - avgReturn, 2), 0\n        ) / returns.length;\n        const stdDev = Math.sqrt(variance);\n        \n        return stdDev === 0 ? 0 : (avgReturn - 0.02) / stdDev; // 2% risk-free rate\n    }\n\n    calculateSharpeRatio(strategy) {\n        const trades = this.tradeHistory.filter(t => t.strategy === strategy);\n        if (trades.length < 2) return 0;\n        \n        const returns = trades.map(t => t.result?.percentReturn || 0);\n        const avgReturn = returns.reduce((a, b) => a + b, 0) / returns.length;\n        const variance = returns.reduce((sum, ret) => \n            sum + Math.pow(ret - avgReturn, 2), 0\n        ) / returns.length;\n        const stdDev = Math.sqrt(variance);\n        \n        return stdDev === 0 ? 0 : (avgReturn - 0.02) / stdDev;\n    }\n\n    calculateMaxDrawdown() {\n        if (this.tradeHistory.length === 0) return 0;\n        \n        let peak = 0;\n        let maxDrawdown = 0;\n        let runningTotal = 0;\n        \n        this.tradeHistory.forEach(trade => {\n            runningTotal += trade.result?.profit || 0;\n            if (runningTotal > peak) {\n                peak = runningTotal;\n            }\n            const drawdown = (peak - runningTotal) / peak;\n            if (drawdown > maxDrawdown) {\n                maxDrawdown = drawdown;\n            }\n        });\n        \n        return maxDrawdown;\n    }\n\n    calculateProfitFactor() {\n        const wins = this.tradeHistory\n            .filter(t => t.result && t.result.profit > 0)\n            .reduce((sum, t) => sum + t.result.profit, 0);\n        \n        const losses = Math.abs(this.tradeHistory\n            .filter(t => t.result && t.result.profit < 0)\n            .reduce((sum, t) => sum + t.result.profit, 0));\n        \n        return losses === 0 ? wins : wins / losses;\n    }\n\n    getMarketData(symbol, marketData) {\n        // Extract symbol-specific data from market data\n        return marketData[symbol] || {\n            symbol,\n            prices: [],\n            volume: 0,\n            currentPrice: 0,\n            highs: [],\n            lows: [],\n            vwap: 0,\n            callVolume: 0,\n            putVolume: 0,\n            unusualActivity: false,\n            socialSentiment: 0,\n            newsSentiment: 0,\n            marketCap: 0,\n            sectorStrength: 0,\n            correlationSPY: 0,\n            avgVolume: 0\n        };\n    }\n}\n\n// Export for use in React components\nexport default MLTradingSystem;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}