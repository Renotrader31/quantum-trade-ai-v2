{"ast":null,"code":"/**\n * Advanced Technical Analysis Engine\n * Comprehensive collection of 20+ technical indicators\n */class TechnicalAnalysis{constructor(){this.indicators={};this.patterns={};}// ==================== MOMENTUM INDICATORS ====================\n/**\n     * Relative Strength Index (RSI)\n     */calculateRSI(prices){let period=arguments.length>1&&arguments[1]!==undefined?arguments[1]:14;if(prices.length<period+1)return null;const gains=[];const losses=[];for(let i=1;i<prices.length;i++){const change=prices[i]-prices[i-1];gains.push(change>0?change:0);losses.push(change<0?-change:0);}const avgGain=gains.slice(0,period).reduce((sum,gain)=>sum+gain,0)/period;const avgLoss=losses.slice(0,period).reduce((sum,loss)=>sum+loss,0)/period;if(avgLoss===0)return 100;const rs=avgGain/avgLoss;return 100-100/(1+rs);}/**\n     * Stochastic Oscillator\n     */calculateStochastic(prices,highs,lows){let kPeriod=arguments.length>3&&arguments[3]!==undefined?arguments[3]:14;let dPeriod=arguments.length>4&&arguments[4]!==undefined?arguments[4]:3;if(prices.length<kPeriod)return null;const kValues=[];for(let i=kPeriod-1;i<prices.length;i++){const periodHigh=Math.max(...highs.slice(i-kPeriod+1,i+1));const periodLow=Math.min(...lows.slice(i-kPeriod+1,i+1));const k=(prices[i]-periodLow)/(periodHigh-periodLow)*100;kValues.push(k);}// Calculate %D (SMA of %K)\nconst dValues=[];for(let i=dPeriod-1;i<kValues.length;i++){const d=kValues.slice(i-dPeriod+1,i+1).reduce((sum,k)=>sum+k,0)/dPeriod;dValues.push(d);}return{k:kValues[kValues.length-1],d:dValues[dValues.length-1],signal:kValues[kValues.length-1]>80?'OVERBOUGHT':kValues[kValues.length-1]<20?'OVERSOLD':'NEUTRAL'};}/**\n     * Williams %R\n     */calculateWilliamsR(prices,highs,lows){let period=arguments.length>3&&arguments[3]!==undefined?arguments[3]:14;if(prices.length<period)return null;const periodHigh=Math.max(...highs.slice(-period));const periodLow=Math.min(...lows.slice(-period));const currentPrice=prices[prices.length-1];return(periodHigh-currentPrice)/(periodHigh-periodLow)*-100;}// ==================== TREND INDICATORS ====================\n/**\n     * Moving Average Convergence Divergence (MACD)\n     */calculateMACD(prices){let fastPeriod=arguments.length>1&&arguments[1]!==undefined?arguments[1]:12;let slowPeriod=arguments.length>2&&arguments[2]!==undefined?arguments[2]:26;let signalPeriod=arguments.length>3&&arguments[3]!==undefined?arguments[3]:9;const fastEMA=this.calculateEMA(prices,fastPeriod);const slowEMA=this.calculateEMA(prices,slowPeriod);if(!fastEMA||!slowEMA)return null;const macdLine=fastEMA-slowEMA;// Calculate signal line (EMA of MACD)\nconst macdHistory=[];for(let i=slowPeriod-1;i<prices.length;i++){const fastEmaAtI=this.calculateEMA(prices.slice(0,i+1),fastPeriod);const slowEmaAtI=this.calculateEMA(prices.slice(0,i+1),slowPeriod);macdHistory.push(fastEmaAtI-slowEmaAtI);}const signalLine=this.calculateEMA(macdHistory,signalPeriod);const histogram=macdLine-signalLine;return{macd:macdLine,signal:signalLine,histogram:histogram,crossover:macdLine>signalLine?'BULLISH':'BEARISH'};}/**\n     * Exponential Moving Average (EMA)\n     */calculateEMA(prices,period){if(prices.length<period)return null;const multiplier=2/(period+1);let ema=prices.slice(0,period).reduce((sum,price)=>sum+price,0)/period;for(let i=period;i<prices.length;i++){ema=(prices[i]-ema)*multiplier+ema;}return ema;}/**\n     * Simple Moving Average (SMA)\n     */calculateSMA(prices,period){if(prices.length<period)return null;const sum=prices.slice(-period).reduce((sum,price)=>sum+price,0);return sum/period;}/**\n     * Average Directional Index (ADX)\n     */calculateADX(highs,lows,closes){let period=arguments.length>3&&arguments[3]!==undefined?arguments[3]:14;if(highs.length<period+1)return null;const trueRanges=[];const plusDMs=[];const minusDMs=[];for(let i=1;i<closes.length;i++){// True Range\nconst tr=Math.max(highs[i]-lows[i],Math.abs(highs[i]-closes[i-1]),Math.abs(lows[i]-closes[i-1]));trueRanges.push(tr);// Directional Movement\nconst plusDM=highs[i]-highs[i-1]>lows[i-1]-lows[i]?Math.max(highs[i]-highs[i-1],0):0;const minusDM=lows[i-1]-lows[i]>highs[i]-highs[i-1]?Math.max(lows[i-1]-lows[i],0):0;plusDMs.push(plusDM);minusDMs.push(minusDM);}// Calculate smoothed values\nconst avgTR=trueRanges.slice(-period).reduce((sum,tr)=>sum+tr,0)/period;const avgPlusDM=plusDMs.slice(-period).reduce((sum,dm)=>sum+dm,0)/period;const avgMinusDM=minusDMs.slice(-period).reduce((sum,dm)=>sum+dm,0)/period;const plusDI=avgPlusDM/avgTR*100;const minusDI=avgMinusDM/avgTR*100;const dx=Math.abs(plusDI-minusDI)/(plusDI+minusDI)*100;return{adx:dx,plusDI:plusDI,minusDI:minusDI,trend:dx>25?plusDI>minusDI?'STRONG_UPTREND':'STRONG_DOWNTREND':'WEAK_TREND'};}// ==================== VOLATILITY INDICATORS ====================\n/**\n     * Bollinger Bands\n     */calculateBollingerBands(prices){let period=arguments.length>1&&arguments[1]!==undefined?arguments[1]:20;let stdDev=arguments.length>2&&arguments[2]!==undefined?arguments[2]:2;if(prices.length<period)return null;const sma=this.calculateSMA(prices,period);const variance=prices.slice(-period).reduce((sum,price)=>sum+Math.pow(price-sma,2),0)/period;const standardDeviation=Math.sqrt(variance);const upperBand=sma+standardDeviation*stdDev;const lowerBand=sma-standardDeviation*stdDev;const currentPrice=prices[prices.length-1];return{upper:upperBand,middle:sma,lower:lowerBand,bandwidth:(upperBand-lowerBand)/sma*100,position:(currentPrice-lowerBand)/(upperBand-lowerBand)*100,signal:currentPrice>upperBand?'OVERBOUGHT':currentPrice<lowerBand?'OVERSOLD':'NEUTRAL'};}/**\n     * Average True Range (ATR)\n     */calculateATR(highs,lows,closes){let period=arguments.length>3&&arguments[3]!==undefined?arguments[3]:14;if(highs.length<period+1)return null;const trueRanges=[];for(let i=1;i<closes.length;i++){const tr=Math.max(highs[i]-lows[i],Math.abs(highs[i]-closes[i-1]),Math.abs(lows[i]-closes[i-1]));trueRanges.push(tr);}return trueRanges.slice(-period).reduce((sum,tr)=>sum+tr,0)/period;}// ==================== VOLUME INDICATORS ====================\n/**\n     * Volume Weighted Average Price (VWAP)\n     */calculateVWAP(prices,volumes){if(prices.length!==volumes.length)return null;let totalPriceVolume=0;let totalVolume=0;for(let i=0;i<prices.length;i++){totalPriceVolume+=prices[i]*volumes[i];totalVolume+=volumes[i];}return totalVolume>0?totalPriceVolume/totalVolume:null;}/**\n     * On-Balance Volume (OBV)\n     */calculateOBV(prices,volumes){if(prices.length!==volumes.length||prices.length<2)return null;let obv=0;const obvValues=[0];for(let i=1;i<prices.length;i++){if(prices[i]>prices[i-1]){obv+=volumes[i];}else if(prices[i]<prices[i-1]){obv-=volumes[i];}obvValues.push(obv);}return obvValues[obvValues.length-1];}// ==================== SUPPORT & RESISTANCE ====================\n/**\n     * Fibonacci Retracement Levels\n     */calculateFibonacci(high,low){const range=high-low;return{level_0:high,level_236:high-range*0.236,level_382:high-range*0.382,level_500:high-range*0.500,level_618:high-range*0.618,level_786:high-range*0.786,level_100:low};}/**\n     * Pivot Points\n     */calculatePivotPoints(high,low,close){const pivot=(high+low+close)/3;return{pivot:pivot,r1:2*pivot-low,r2:pivot+(high-low),r3:high+2*(pivot-low),s1:2*pivot-high,s2:pivot-(high-low),s3:low-2*(high-pivot)};}// ==================== PATTERN RECOGNITION ====================\n/**\n     * Detect Candlestick Patterns\n     */detectCandlestickPatterns(ohlcData){if(ohlcData.length<3)return[];const patterns=[];const current=ohlcData[ohlcData.length-1];const previous=ohlcData[ohlcData.length-2];const beforePrevious=ohlcData[ohlcData.length-3];// Doji\nif(Math.abs(current.close-current.open)<(current.high-current.low)*0.1){patterns.push({name:'Doji',type:'REVERSAL',confidence:70,signal:'NEUTRAL'});}// Hammer\nconst bodySize=Math.abs(current.close-current.open);const lowerShadow=current.open<current.close?current.open-current.low:current.close-current.low;const upperShadow=current.high-Math.max(current.open,current.close);if(lowerShadow>bodySize*2&&upperShadow<bodySize*0.5){patterns.push({name:'Hammer',type:'REVERSAL',confidence:75,signal:'BULLISH'});}// Engulfing Pattern\nif(previous.close>previous.open&&current.open<current.close&&current.open<previous.close&&current.close>previous.open){patterns.push({name:'Bullish Engulfing',type:'REVERSAL',confidence:80,signal:'BULLISH'});}return patterns;}/**\n     * Detect Chart Patterns\n     */detectChartPatterns(prices){let period=arguments.length>1&&arguments[1]!==undefined?arguments[1]:20;if(prices.length<period)return[];const patterns=[];const recentPrices=prices.slice(-period);const high=Math.max(...recentPrices);const low=Math.min(...recentPrices);const current=prices[prices.length-1];// Breakout Detection\nconst sma20=this.calculateSMA(prices,20);if(current>high*0.99){patterns.push({name:'Upward Breakout',type:'CONTINUATION',confidence:85,signal:'BULLISH'});}if(current<low*1.01){patterns.push({name:'Downward Breakdown',type:'CONTINUATION',confidence:85,signal:'BEARISH'});}// Triangle Pattern Detection\nconst slope1=this.calculateSlope(recentPrices.slice(0,10));const slope2=this.calculateSlope(recentPrices.slice(10));if(Math.abs(slope1)<0.1&&Math.abs(slope2)<0.1){patterns.push({name:'Symmetrical Triangle',type:'CONTINUATION',confidence:70,signal:'NEUTRAL'});}return patterns;}/**\n     * Calculate slope of price series\n     */calculateSlope(prices){const n=prices.length;const sumX=n*(n-1)/2;const sumY=prices.reduce((sum,price)=>sum+price,0);const sumXY=prices.reduce((sum,price,index)=>sum+index*price,0);const sumX2=n*(n-1)*(2*n-1)/6;return(n*sumXY-sumX*sumY)/(n*sumX2-sumX*sumX);}// ==================== COMPREHENSIVE ANALYSIS ====================\n/**\n     * Perform complete technical analysis on stock data\n     */performCompleteAnalysis(stockData){let historicalData=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;const prices=historicalData?historicalData.closes:this.generatePriceHistory(stockData.price);const highs=historicalData?historicalData.highs:this.generatePriceHistory(stockData.high);const lows=historicalData?historicalData.lows:this.generatePriceHistory(stockData.low);const volumes=historicalData?historicalData.volumes:this.generateVolumeHistory(stockData.volume);return{// Momentum Indicators\nrsi:this.calculateRSI(prices),stochastic:this.calculateStochastic(prices,highs,lows),williamsR:this.calculateWilliamsR(prices,highs,lows),// Trend Indicators\nmacd:this.calculateMACD(prices),sma20:this.calculateSMA(prices,20),sma50:this.calculateSMA(prices,50),ema12:this.calculateEMA(prices,12),ema26:this.calculateEMA(prices,26),adx:this.calculateADX(highs,lows,prices),// Volatility Indicators\nbollingerBands:this.calculateBollingerBands(prices),atr:this.calculateATR(highs,lows,prices),// Volume Indicators\nvwap:this.calculateVWAP(prices,volumes),obv:this.calculateOBV(prices,volumes),// Support & Resistance\nfibonacci:this.calculateFibonacci(Math.max(...highs),Math.min(...lows)),pivotPoints:this.calculatePivotPoints(stockData.high,stockData.low,stockData.price),// Pattern Recognition\ncandlestickPatterns:this.detectCandlestickPatterns(this.generateOHLCData(stockData,prices)),chartPatterns:this.detectChartPatterns(prices),// Overall Signal\noverallSignal:this.calculateOverallSignal({rsi:this.calculateRSI(prices),macd:this.calculateMACD(prices),bollingerBands:this.calculateBollingerBands(prices),adx:this.calculateADX(highs,lows,prices)})};}/**\n     * Calculate overall trading signal from multiple indicators\n     */calculateOverallSignal(indicators){let bullishSignals=0;let bearishSignals=0;let totalSignals=0;// RSI Analysis\nif(indicators.rsi){totalSignals++;if(indicators.rsi<30)bullishSignals++;else if(indicators.rsi>70)bearishSignals++;}// MACD Analysis\nif(indicators.macd){totalSignals++;if(indicators.macd.crossover==='BULLISH')bullishSignals++;else if(indicators.macd.crossover==='BEARISH')bearishSignals++;}// Bollinger Bands Analysis\nif(indicators.bollingerBands){totalSignals++;if(indicators.bollingerBands.signal==='OVERSOLD')bullishSignals++;else if(indicators.bollingerBands.signal==='OVERBOUGHT')bearishSignals++;}// ADX Analysis\nif(indicators.adx){totalSignals++;if(indicators.adx.trend==='STRONG_UPTREND')bullishSignals++;else if(indicators.adx.trend==='STRONG_DOWNTREND')bearishSignals++;}const bullishPercentage=bullishSignals/totalSignals*100;const bearishPercentage=bearishSignals/totalSignals*100;return{signal:bullishPercentage>60?'STRONG_BUY':bullishPercentage>40?'BUY':bearishPercentage>60?'STRONG_SELL':bearishPercentage>40?'SELL':'HOLD',confidence:Math.max(bullishPercentage,bearishPercentage),bullishSignals,bearishSignals,totalSignals};}// ==================== HELPER METHODS ====================\ngeneratePriceHistory(currentPrice){let days=arguments.length>1&&arguments[1]!==undefined?arguments[1]:50;const prices=[];let price=currentPrice*0.95;// Start slightly lower\nfor(let i=0;i<days;i++){price=price*(1+(Math.random()-0.5)*0.03);prices.push(price);}return prices;}generateVolumeHistory(currentVolume){let days=arguments.length>1&&arguments[1]!==undefined?arguments[1]:50;const volumes=[];let volume=currentVolume;for(let i=0;i<days;i++){volume=Math.max(volume*(1+(Math.random()-0.5)*0.5),100000);volumes.push(Math.floor(volume));}return volumes;}generateOHLCData(stockData,prices){const ohlc=[];for(let i=0;i<Math.min(prices.length,10);i++){const price=prices[i];ohlc.push({open:price*(1+(Math.random()-0.5)*0.02),high:price*(1+Math.random()*0.03),low:price*(1-Math.random()*0.03),close:price});}return ohlc;}}export default new TechnicalAnalysis();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}