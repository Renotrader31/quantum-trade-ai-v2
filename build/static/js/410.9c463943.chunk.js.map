{"version":3,"file":"static/js/410.9c463943.chunk.js","mappings":"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","sources":["services/MLTradingSystem.js"],"sourcesContent":["/**\n * Advanced Machine Learning Trading System\n * Self-improving algorithm that learns from every trade and strategy\n */\n\nconst isBrowser = typeof window !== 'undefined';\n\nclass MLTradingSystem {\n    constructor() {\n        this.model = {\n            version: '2.0',\n            accuracy: 0.65, // Starting accuracy\n            confidence: 0.5,\n            trainingData: [],\n            patterns: new Map(),\n            strategies: new Map(),\n            performance: new Map()\n        };\n        \n        this.features = {\n            technical: ['rsi', 'macd', 'bollinger', 'vwap', 'ema', 'sma'],\n            sentiment: ['social', 'news', 'options_flow'],\n            market: ['volume', 'volatility', 'trend', 'momentum']\n        };\n        \n        this.tradeHistory = [];\n        this.activeTrades = [];\n        this.recommendations = [];\n        \n        this.loadModel();\n        this.initializeNeuralNetwork();\n    }\n\n    /**\n     * Initialize a simple neural network for pattern recognition\n     */\n    initializeNeuralNetwork() {\n        this.network = {\n            inputLayer: 15, // Number of input features\n            hiddenLayers: [30, 20, 10], // 3 hidden layers\n            outputLayer: 5, // Buy strong, buy, hold, sell, sell strong\n            weights: this.initializeWeights(),\n            learningRate: 0.01\n        };\n    }\n\n    initializeWeights() {\n        // Initialize random weights for the neural network\n        const weights = {};\n        \n        // Input to first hidden layer\n        weights.ih = Array(30).fill(0).map(() => \n            Array(15).fill(0).map(() => Math.random() - 0.5)\n        );\n        \n        // Hidden layers\n        weights.hh1 = Array(20).fill(0).map(() => \n            Array(30).fill(0).map(() => Math.random() - 0.5)\n        );\n        weights.hh2 = Array(10).fill(0).map(() => \n            Array(20).fill(0).map(() => Math.random() - 0.5)\n        );\n        \n        // Hidden to output\n        weights.ho = Array(5).fill(0).map(() => \n            Array(10).fill(0).map(() => Math.random() - 0.5)\n        );\n        \n        return weights;\n    }\n\n    /**\n     * Load saved model from storage\n     */\n    loadModel() {\n        if (!isBrowser) return;\n        \n        const savedModel = localStorage.getItem('mlTradingModel');\n        if (savedModel) {\n            try {\n                const parsed = JSON.parse(savedModel);\n                this.model = { ...this.model, ...parsed };\n                \n                // Convert arrays back to Maps\n                if (parsed.patterns) {\n                    this.model.patterns = new Map(parsed.patterns);\n                }\n                if (parsed.strategies) {\n                    this.model.strategies = new Map(parsed.strategies);\n                }\n                if (parsed.performance) {\n                    this.model.performance = new Map(parsed.performance);\n                }\n                \n                console.log('ML Model loaded. Accuracy:', this.model.accuracy);\n            } catch (e) {\n                console.log('Starting fresh ML model');\n            }\n        }\n        \n        const savedHistory = localStorage.getItem('mlTradeHistory');\n        if (savedHistory) {\n            this.tradeHistory = JSON.parse(savedHistory);\n        }\n    }\n\n    /**\n     * Save model to storage\n     */\n    saveModel() {\n        if (!isBrowser) return;\n        \n        const modelToSave = {\n            ...this.model,\n            patterns: Array.from(this.model.patterns.entries()),\n            strategies: Array.from(this.model.strategies.entries()),\n            performance: Array.from(this.model.performance.entries())\n        };\n        \n        localStorage.setItem('mlTradingModel', JSON.stringify(modelToSave));\n        localStorage.setItem('mlTradeHistory', JSON.stringify(this.tradeHistory));\n    }\n\n    /**\n     * Extract features from market data\n     */\n    extractFeatures(data) {\n        const features = [];\n        \n        // Technical indicators\n        features.push(this.calculateRSI(data.prices));\n        features.push(this.calculateMACD(data.prices));\n        features.push(this.calculateBollingerBands(data.prices));\n        features.push(data.vwap || 0);\n        \n        // Volume and volatility\n        features.push(this.normalizeVolume(data.volume));\n        features.push(this.calculateVolatility(data.prices));\n        \n        // Trend indicators\n        features.push(this.calculateTrend(data.prices));\n        features.push(this.calculateMomentum(data.prices));\n        \n        // Options flow\n        features.push(data.callVolume / (data.putVolume || 1)); // Call/Put ratio\n        features.push(data.unusualActivity ? 1 : 0);\n        \n        // Sentiment scores\n        features.push(data.socialSentiment || 0);\n        features.push(data.newsSentiment || 0);\n        \n        // Market conditions\n        features.push(data.marketCap || 0);\n        features.push(data.sectorStrength || 0);\n        features.push(data.correlationSPY || 0);\n        \n        return features.map(f => isNaN(f) ? 0 : f); // Handle NaN values\n    }\n\n    /**\n     * Forward propagation through the neural network\n     */\n    predict(features) {\n        let current = features;\n        const { weights } = this.network;\n        \n        // Input to hidden layer 1\n        current = this.activate(this.matrixMultiply(current, weights.ih));\n        \n        // Hidden layer 1 to 2\n        current = this.activate(this.matrixMultiply(current, weights.hh1));\n        \n        // Hidden layer 2 to 3\n        current = this.activate(this.matrixMultiply(current, weights.hh2));\n        \n        // Hidden layer 3 to output\n        const output = this.softmax(this.matrixMultiply(current, weights.ho));\n        \n        return {\n            buyStrong: output[0],\n            buy: output[1],\n            hold: output[2],\n            sell: output[3],\n            sellStrong: output[4],\n            confidence: Math.max(...output)\n        };\n    }\n\n    /**\n     * Train the model with new data\n     */\n    async train(tradeData) {\n        const features = this.extractFeatures(tradeData.marketData);\n        const actualOutcome = this.encodeOutcome(tradeData.result);\n        \n        // Store training data\n        this.model.trainingData.push({\n            features,\n            outcome: actualOutcome,\n            timestamp: Date.now(),\n            symbol: tradeData.symbol,\n            strategy: tradeData.strategy\n        });\n        \n        // Keep only recent data (last 10,000 trades)\n        if (this.model.trainingData.length > 10000) {\n            this.model.trainingData = this.model.trainingData.slice(-10000);\n        }\n        \n        // Backpropagation\n        await this.backpropagate(features, actualOutcome);\n        \n        // Update patterns\n        this.updatePatterns(tradeData);\n        \n        // Update strategy performance\n        this.updateStrategyPerformance(tradeData);\n        \n        // Recalculate model accuracy\n        this.updateModelAccuracy();\n        \n        // Save the updated model\n        this.saveModel();\n        \n        return {\n            accuracy: this.model.accuracy,\n            confidence: this.model.confidence,\n            totalTrades: this.model.trainingData.length\n        };\n    }\n\n    /**\n     * Backpropagation for neural network training\n     */\n    async backpropagate(features, target) {\n        const prediction = this.predict(features);\n        const error = this.calculateError(prediction, target);\n        \n        // Update weights based on error (simplified)\n        const { weights, learningRate } = this.network;\n        \n        // This is a simplified version - real implementation would be more complex\n        Object.keys(weights).forEach(layer => {\n            weights[layer] = weights[layer].map(row =>\n                row.map(w => w - learningRate * error * Math.random())\n            );\n        });\n        \n        this.network.weights = weights;\n    }\n\n    /**\n     * Identify and learn patterns\n     */\n    updatePatterns(tradeData) {\n        const pattern = this.identifyPattern(tradeData.marketData);\n        \n        if (!this.model.patterns.has(pattern.type)) {\n            this.model.patterns.set(pattern.type, {\n                occurrences: 0,\n                successRate: 0,\n                totalReturn: 0\n            });\n        }\n        \n        const patternStats = this.model.patterns.get(pattern.type);\n        patternStats.occurrences++;\n        \n        if (tradeData.result.profit > 0) {\n            patternStats.successRate = \n                (patternStats.successRate * (patternStats.occurrences - 1) + 1) / \n                patternStats.occurrences;\n        } else {\n            patternStats.successRate = \n                (patternStats.successRate * (patternStats.occurrences - 1)) / \n                patternStats.occurrences;\n        }\n        \n        patternStats.totalReturn += tradeData.result.percentReturn;\n        \n        this.model.patterns.set(pattern.type, patternStats);\n    }\n\n    /**\n     * Identify market patterns\n     */\n    identifyPattern(marketData) {\n        const patterns = [];\n        \n        // Bullish patterns\n        if (this.isGoldenCross(marketData)) patterns.push('golden_cross');\n        if (this.isBullFlag(marketData)) patterns.push('bull_flag');\n        if (this.isCupAndHandle(marketData)) patterns.push('cup_handle');\n        \n        // Bearish patterns\n        if (this.isDeathCross(marketData)) patterns.push('death_cross');\n        if (this.isBearFlag(marketData)) patterns.push('bear_flag');\n        if (this.isHeadAndShoulders(marketData)) patterns.push('head_shoulders');\n        \n        // Neutral patterns\n        if (this.isTriangle(marketData)) patterns.push('triangle');\n        if (this.isRange(marketData)) patterns.push('range_bound');\n        \n        return {\n            type: patterns.join('_') || 'unknown',\n            patterns: patterns\n        };\n    }\n\n    /**\n     * Update strategy performance metrics\n     */\n    updateStrategyPerformance(tradeData) {\n        const { strategy } = tradeData;\n        \n        if (!this.model.strategies.has(strategy)) {\n            this.model.strategies.set(strategy, {\n                trades: 0,\n                wins: 0,\n                losses: 0,\n                totalReturn: 0,\n                avgReturn: 0,\n                winRate: 0,\n                sharpeRatio: 0\n            });\n        }\n        \n        const stats = this.model.strategies.get(strategy);\n        stats.trades++;\n        \n        if (tradeData.result.profit > 0) {\n            stats.wins++;\n        } else {\n            stats.losses++;\n        }\n        \n        stats.totalReturn += tradeData.result.percentReturn;\n        stats.avgReturn = stats.totalReturn / stats.trades;\n        stats.winRate = stats.wins / stats.trades;\n        \n        // Calculate Sharpe ratio (simplified)\n        stats.sharpeRatio = this.calculateSharpeRatio(strategy);\n        \n        this.model.strategies.set(strategy, stats);\n    }\n\n    /**\n     * Generate AI-powered recommendations\n     */\n    generateRecommendations(marketData, options = {}) {\n        const recommendations = [];\n        const symbols = options.symbols || ['SPY', 'QQQ', 'AAPL', 'NVDA', 'TSLA'];\n        \n        symbols.forEach(symbol => {\n            const symbolData = this.getMarketData(symbol, marketData);\n            const features = this.extractFeatures(symbolData);\n            const prediction = this.predict(features);\n            const pattern = this.identifyPattern(symbolData);\n            \n            // Get historical performance for this pattern\n            const patternPerformance = this.model.patterns.get(pattern.type) || {\n                successRate: 0.5,\n                occurrences: 0\n            };\n            \n            // Generate recommendation\n            const action = this.determineAction(prediction);\n            \n            if (action !== 'hold' || options.includeHold) {\n                recommendations.push({\n                    symbol,\n                    action,\n                    confidence: prediction.confidence,\n                    expectedReturn: this.calculateExpectedReturn(prediction, patternPerformance),\n                    risk: this.calculateRisk(symbolData),\n                    pattern: pattern.type,\n                    patternSuccess: patternPerformance.successRate,\n                    reasoning: this.generateReasoning(prediction, pattern, symbolData),\n                    timeframe: options.timeframe || '1D',\n                    entryPrice: symbolData.currentPrice,\n                    stopLoss: this.calculateStopLoss(symbolData, action),\n                    takeProfit: this.calculateTakeProfit(symbolData, action),\n                    positionSize: this.calculatePositionSize(symbolData, options.capital || 10000)\n                });\n            }\n        });\n        \n        // Sort by confidence and expected return\n        recommendations.sort((a, b) => \n            (b.confidence * b.expectedReturn) - (a.confidence * a.expectedReturn)\n        );\n        \n        return recommendations.slice(0, options.limit || 5);\n    }\n\n    /**\n     * Record actual trade for learning\n     */\n    recordTrade(trade) {\n        // Add to trade history\n        this.tradeHistory.push({\n            ...trade,\n            timestamp: Date.now(),\n            modelVersion: this.model.version,\n            modelAccuracy: this.model.accuracy\n        });\n        \n        // If trade is closed, train the model\n        if (trade.status === 'closed') {\n            this.train({\n                symbol: trade.symbol,\n                strategy: trade.strategy,\n                marketData: trade.entryMarketData,\n                result: {\n                    profit: trade.profit,\n                    percentReturn: trade.percentReturn,\n                    holdingPeriod: trade.exitTime - trade.entryTime\n                }\n            });\n        }\n        \n        // Update active trades\n        if (trade.status === 'open') {\n            this.activeTrades.push(trade);\n        } else {\n            this.activeTrades = this.activeTrades.filter(t => t.id !== trade.id);\n        }\n        \n        this.saveModel();\n    }\n\n    /**\n     * Get performance metrics\n     */\n    getPerformanceMetrics() {\n        const metrics = {\n            modelAccuracy: this.model.accuracy,\n            modelConfidence: this.model.confidence,\n            totalTrades: this.tradeHistory.length,\n            winRate: this.calculateWinRate(),\n            avgReturn: this.calculateAvgReturn(),\n            sharpeRatio: this.calculateOverallSharpe(),\n            maxDrawdown: this.calculateMaxDrawdown(),\n            profitFactor: this.calculateProfitFactor(),\n            strategies: Array.from(this.model.strategies.entries()).map(([name, stats]) => ({\n                name,\n                ...stats\n            })),\n            patterns: Array.from(this.model.patterns.entries())\n                .sort((a, b) => b[1].successRate - a[1].successRate)\n                .slice(0, 10)\n                .map(([name, stats]) => ({\n                    name,\n                    ...stats\n                })),\n            recentTrades: this.tradeHistory.slice(-10),\n            activeTrades: this.activeTrades\n        };\n        \n        return metrics;\n    }\n\n    /**\n     * Calculate technical indicators\n     */\n    calculateRSI(prices, period = 14) {\n        if (prices.length < period) return 50;\n        \n        let gains = 0;\n        let losses = 0;\n        \n        for (let i = 1; i < period; i++) {\n            const diff = prices[i] - prices[i - 1];\n            if (diff > 0) gains += diff;\n            else losses -= diff;\n        }\n        \n        const avgGain = gains / period;\n        const avgLoss = losses / period;\n        const rs = avgGain / (avgLoss || 1);\n        const rsi = 100 - (100 / (1 + rs));\n        \n        return rsi;\n    }\n\n    calculateMACD(prices) {\n        const ema12 = this.calculateEMA(prices, 12);\n        const ema26 = this.calculateEMA(prices, 26);\n        return ema12 - ema26;\n    }\n\n    calculateEMA(prices, period) {\n        if (prices.length === 0) return 0;\n        \n        const multiplier = 2 / (period + 1);\n        let ema = prices[0];\n        \n        for (let i = 1; i < prices.length; i++) {\n            ema = (prices[i] - ema) * multiplier + ema;\n        }\n        \n        return ema;\n    }\n\n    calculateBollingerBands(prices, period = 20) {\n        const sma = prices.slice(-period).reduce((a, b) => a + b, 0) / period;\n        const variance = prices.slice(-period).reduce((sum, price) => \n            sum + Math.pow(price - sma, 2), 0) / period;\n        const stdDev = Math.sqrt(variance);\n        \n        const current = prices[prices.length - 1];\n        const position = (current - sma) / (stdDev * 2); // Position within bands\n        \n        return position; // -1 to 1, where -1 is lower band, 1 is upper band\n    }\n\n    calculateVolatility(prices) {\n        if (prices.length < 2) return 0;\n        \n        const returns = [];\n        for (let i = 1; i < prices.length; i++) {\n            returns.push((prices[i] - prices[i - 1]) / prices[i - 1]);\n        }\n        \n        const avgReturn = returns.reduce((a, b) => a + b, 0) / returns.length;\n        const variance = returns.reduce((sum, ret) => \n            sum + Math.pow(ret - avgReturn, 2), 0) / returns.length;\n        \n        return Math.sqrt(variance * 252); // Annualized volatility\n    }\n\n    calculateTrend(prices) {\n        if (prices.length < 2) return 0;\n        \n        // Simple linear regression\n        const n = prices.length;\n        const indices = Array.from({ length: n }, (_, i) => i);\n        \n        const sumX = indices.reduce((a, b) => a + b, 0);\n        const sumY = prices.reduce((a, b) => a + b, 0);\n        const sumXY = indices.reduce((sum, x, i) => sum + x * prices[i], 0);\n        const sumX2 = indices.reduce((sum, x) => sum + x * x, 0);\n        \n        const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);\n        \n        return slope; // Positive = uptrend, negative = downtrend\n    }\n\n    calculateMomentum(prices, period = 10) {\n        if (prices.length < period) return 0;\n        \n        const current = prices[prices.length - 1];\n        const past = prices[prices.length - period];\n        \n        return (current - past) / past;\n    }\n\n    /**\n     * Pattern detection methods\n     */\n    isGoldenCross(data) {\n        const sma50 = this.calculateSMA(data.prices, 50);\n        const sma200 = this.calculateSMA(data.prices, 200);\n        const prevSma50 = this.calculateSMA(data.prices.slice(0, -1), 50);\n        const prevSma200 = this.calculateSMA(data.prices.slice(0, -1), 200);\n        \n        return prevSma50 <= prevSma200 && sma50 > sma200;\n    }\n\n    isDeathCross(data) {\n        const sma50 = this.calculateSMA(data.prices, 50);\n        const sma200 = this.calculateSMA(data.prices, 200);\n        const prevSma50 = this.calculateSMA(data.prices.slice(0, -1), 50);\n        const prevSma200 = this.calculateSMA(data.prices.slice(0, -1), 200);\n        \n        return prevSma50 >= prevSma200 && sma50 < sma200;\n    }\n\n    isBullFlag(data) {\n        // Simplified bull flag detection\n        const recent = data.prices.slice(-20);\n        const trend = this.calculateTrend(recent);\n        const consolidation = this.calculateVolatility(recent.slice(-5));\n        \n        return trend > 0.02 && consolidation < 0.1;\n    }\n\n    isBearFlag(data) {\n        const recent = data.prices.slice(-20);\n        const trend = this.calculateTrend(recent);\n        const consolidation = this.calculateVolatility(recent.slice(-5));\n        \n        return trend < -0.02 && consolidation < 0.1;\n    }\n\n    isCupAndHandle(data) {\n        // Simplified cup and handle detection\n        if (data.prices.length < 50) return false;\n        \n        const prices = data.prices.slice(-50);\n        const midPoint = Math.floor(prices.length / 2);\n        const leftHigh = Math.max(...prices.slice(0, midPoint));\n        const bottom = Math.min(...prices.slice(midPoint - 10, midPoint + 10));\n        const rightHigh = Math.max(...prices.slice(midPoint));\n        \n        return (\n            Math.abs(leftHigh - rightHigh) / leftHigh < 0.05 &&\n            (leftHigh - bottom) / leftHigh > 0.1\n        );\n    }\n\n    isHeadAndShoulders(data) {\n        // Simplified head and shoulders detection\n        if (data.prices.length < 30) return false;\n        \n        const prices = data.prices.slice(-30);\n        const third = Math.floor(prices.length / 3);\n        \n        const leftShoulder = Math.max(...prices.slice(0, third));\n        const head = Math.max(...prices.slice(third, third * 2));\n        const rightShoulder = Math.max(...prices.slice(third * 2));\n        \n        return (\n            head > leftShoulder &&\n            head > rightShoulder &&\n            Math.abs(leftShoulder - rightShoulder) / leftShoulder < 0.05\n        );\n    }\n\n    isTriangle(data) {\n        // Simplified triangle pattern detection\n        const highs = [];\n        const lows = [];\n        const period = 5;\n        \n        for (let i = 0; i < data.prices.length - period; i += period) {\n            const slice = data.prices.slice(i, i + period);\n            highs.push(Math.max(...slice));\n            lows.push(Math.min(...slice));\n        }\n        \n        const highTrend = this.calculateTrend(highs);\n        const lowTrend = this.calculateTrend(lows);\n        \n        return Math.abs(highTrend) < 0.01 && lowTrend > 0.01;\n    }\n\n    isRange(data) {\n        const volatility = this.calculateVolatility(data.prices);\n        const trend = Math.abs(this.calculateTrend(data.prices));\n        \n        return volatility < 0.15 && trend < 0.001;\n    }\n\n    /**\n     * Helper methods\n     */\n    calculateSMA(prices, period) {\n        if (prices.length < period) return prices[prices.length - 1] || 0;\n        return prices.slice(-period).reduce((a, b) => a + b, 0) / period;\n    }\n\n    normalizeVolume(volume) {\n        // Normalize volume to 0-1 scale\n        const avgVolume = 10000000; // 10M average\n        return Math.min(volume / avgVolume, 2);\n    }\n\n    activate(x) {\n        // ReLU activation\n        return Array.isArray(x) ? x.map(v => Math.max(0, v)) : Math.max(0, x);\n    }\n\n    softmax(x) {\n        const max = Math.max(...x);\n        const exp = x.map(v => Math.exp(v - max));\n        const sum = exp.reduce((a, b) => a + b, 0);\n        return exp.map(v => v / sum);\n    }\n\n    matrixMultiply(vector, matrix) {\n        return matrix.map(row =>\n            row.reduce((sum, val, i) => sum + val * (vector[i] || 0), 0)\n        );\n    }\n\n    calculateError(prediction, target) {\n        const predArray = [\n            prediction.buyStrong,\n            prediction.buy,\n            prediction.hold,\n            prediction.sell,\n            prediction.sellStrong\n        ];\n        \n        return predArray.reduce((sum, val, i) => \n            sum + Math.pow(val - (target[i] || 0), 2), 0\n        );\n    }\n\n    encodeOutcome(result) {\n        // Encode trading outcome to neural network output format\n        const returnPercent = result.percentReturn;\n        \n        if (returnPercent > 10) return [1, 0, 0, 0, 0]; // Buy Strong\n        if (returnPercent > 3) return [0, 1, 0, 0, 0];  // Buy\n        if (returnPercent > -3) return [0, 0, 1, 0, 0]; // Hold\n        if (returnPercent > -10) return [0, 0, 0, 1, 0]; // Sell\n        return [0, 0, 0, 0, 1]; // Sell Strong\n    }\n\n    determineAction(prediction) {\n        const actions = ['buyStrong', 'buy', 'hold', 'sell', 'sellStrong'];\n        const values = [\n            prediction.buyStrong,\n            prediction.buy,\n            prediction.hold,\n            prediction.sell,\n            prediction.sellStrong\n        ];\n        \n        const maxIndex = values.indexOf(Math.max(...values));\n        return actions[maxIndex];\n    }\n\n    calculateExpectedReturn(prediction, patternPerformance) {\n        const baseReturn = \n            prediction.buyStrong * 15 +\n            prediction.buy * 7 +\n            prediction.hold * 0 +\n            prediction.sell * -7 +\n            prediction.sellStrong * -15;\n        \n        // Adjust based on pattern performance\n        const patternAdjustment = (patternPerformance.successRate - 0.5) * 10;\n        \n        return baseReturn + patternAdjustment;\n    }\n\n    calculateRisk(data) {\n        const volatility = this.calculateVolatility(data.prices);\n        const atr = this.calculateATR(data);\n        \n        return Math.min(volatility * atr, 1);\n    }\n\n    calculateATR(data, period = 14) {\n        // Average True Range calculation\n        if (!data.highs || !data.lows || data.highs.length < period) {\n            return 0.02; // Default 2%\n        }\n        \n        const trueRanges = [];\n        for (let i = 1; i < data.highs.length; i++) {\n            const high = data.highs[i];\n            const low = data.lows[i];\n            const prevClose = data.prices[i - 1];\n            \n            const tr = Math.max(\n                high - low,\n                Math.abs(high - prevClose),\n                Math.abs(low - prevClose)\n            );\n            trueRanges.push(tr);\n        }\n        \n        const atr = trueRanges.slice(-period).reduce((a, b) => a + b, 0) / period;\n        return atr / data.prices[data.prices.length - 1];\n    }\n\n    calculateStopLoss(data, action) {\n        const atr = this.calculateATR(data);\n        const currentPrice = data.currentPrice;\n        \n        if (action.includes('buy')) {\n            return currentPrice * (1 - atr * 2);\n        } else if (action.includes('sell')) {\n            return currentPrice * (1 + atr * 2);\n        }\n        return currentPrice;\n    }\n\n    calculateTakeProfit(data, action) {\n        const atr = this.calculateATR(data);\n        const currentPrice = data.currentPrice;\n        \n        if (action.includes('buy')) {\n            return currentPrice * (1 + atr * 3);\n        } else if (action.includes('sell')) {\n            return currentPrice * (1 - atr * 3);\n        }\n        return currentPrice;\n    }\n\n    calculatePositionSize(data, capital) {\n        const risk = this.calculateRisk(data);\n        const maxRisk = 0.02; // Max 2% risk per trade\n        \n        const positionSize = (capital * maxRisk) / risk;\n        return Math.min(positionSize, capital * 0.25); // Max 25% per position\n    }\n\n    generateReasoning(prediction, pattern, data) {\n        const reasons = [];\n        \n        // Add prediction reasoning\n        if (prediction.buyStrong > 0.5) {\n            reasons.push('Strong bullish signals detected');\n        } else if (prediction.buy > 0.5) {\n            reasons.push('Moderate bullish signals present');\n        } else if (prediction.sell > 0.5) {\n            reasons.push('Bearish indicators dominating');\n        }\n        \n        // Add pattern reasoning\n        if (pattern.patterns.length > 0) {\n            reasons.push(`Pattern detected: ${pattern.patterns.join(', ')}`);\n        }\n        \n        // Add technical reasoning\n        const rsi = this.calculateRSI(data.prices);\n        if (rsi < 30) reasons.push('RSI indicates oversold conditions');\n        if (rsi > 70) reasons.push('RSI indicates overbought conditions');\n        \n        // Add volume reasoning\n        if (data.volume > data.avgVolume * 1.5) {\n            reasons.push('Unusual volume detected');\n        }\n        \n        // Add confidence reasoning\n        reasons.push(`Model confidence: ${(prediction.confidence * 100).toFixed(1)}%`);\n        \n        return reasons.join('. ');\n    }\n\n    updateModelAccuracy() {\n        if (this.tradeHistory.length < 10) return;\n        \n        const recentTrades = this.tradeHistory.slice(-100);\n        const correctPredictions = recentTrades.filter(trade => \n            (trade.prediction === 'buy' && trade.result && trade.result.profit > 0) ||\n            (trade.prediction === 'sell' && trade.result && trade.result.profit > 0) ||\n            (trade.prediction === 'hold' && trade.result && Math.abs(trade.result.percentReturn) < 2)\n        ).length;\n        \n        this.model.accuracy = correctPredictions / recentTrades.length;\n        this.model.confidence = Math.min(this.model.accuracy * 1.2, 1);\n    }\n\n    calculateWinRate() {\n        if (this.tradeHistory.length === 0) return 0;\n        \n        const wins = this.tradeHistory.filter(t => t.result && t.result.profit > 0).length;\n        return wins / this.tradeHistory.length;\n    }\n\n    calculateAvgReturn() {\n        if (this.tradeHistory.length === 0) return 0;\n        \n        const totalReturn = this.tradeHistory.reduce((sum, trade) => \n            sum + (trade.result?.percentReturn || 0), 0\n        );\n        \n        return totalReturn / this.tradeHistory.length;\n    }\n\n    calculateOverallSharpe() {\n        if (this.tradeHistory.length < 2) return 0;\n        \n        const returns = this.tradeHistory.map(t => t.result?.percentReturn || 0);\n        const avgReturn = returns.reduce((a, b) => a + b, 0) / returns.length;\n        const variance = returns.reduce((sum, ret) => \n            sum + Math.pow(ret - avgReturn, 2), 0\n        ) / returns.length;\n        const stdDev = Math.sqrt(variance);\n        \n        return stdDev === 0 ? 0 : (avgReturn - 0.02) / stdDev; // 2% risk-free rate\n    }\n\n    calculateSharpeRatio(strategy) {\n        const trades = this.tradeHistory.filter(t => t.strategy === strategy);\n        if (trades.length < 2) return 0;\n        \n        const returns = trades.map(t => t.result?.percentReturn || 0);\n        const avgReturn = returns.reduce((a, b) => a + b, 0) / returns.length;\n        const variance = returns.reduce((sum, ret) => \n            sum + Math.pow(ret - avgReturn, 2), 0\n        ) / returns.length;\n        const stdDev = Math.sqrt(variance);\n        \n        return stdDev === 0 ? 0 : (avgReturn - 0.02) / stdDev;\n    }\n\n    calculateMaxDrawdown() {\n        if (this.tradeHistory.length === 0) return 0;\n        \n        let peak = 0;\n        let maxDrawdown = 0;\n        let runningTotal = 0;\n        \n        this.tradeHistory.forEach(trade => {\n            runningTotal += trade.result?.profit || 0;\n            if (runningTotal > peak) {\n                peak = runningTotal;\n            }\n            const drawdown = (peak - runningTotal) / peak;\n            if (drawdown > maxDrawdown) {\n                maxDrawdown = drawdown;\n            }\n        });\n        \n        return maxDrawdown;\n    }\n\n    calculateProfitFactor() {\n        const wins = this.tradeHistory\n            .filter(t => t.result && t.result.profit > 0)\n            .reduce((sum, t) => sum + t.result.profit, 0);\n        \n        const losses = Math.abs(this.tradeHistory\n            .filter(t => t.result && t.result.profit < 0)\n            .reduce((sum, t) => sum + t.result.profit, 0));\n        \n        return losses === 0 ? wins : wins / losses;\n    }\n\n    getMarketData(symbol, marketData) {\n        // Extract symbol-specific data from market data\n        return marketData[symbol] || {\n            symbol,\n            prices: [],\n            volume: 0,\n            currentPrice: 0,\n            highs: [],\n            lows: [],\n            vwap: 0,\n            callVolume: 0,\n            putVolume: 0,\n            unusualActivity: false,\n            socialSentiment: 0,\n            newsSentiment: 0,\n            marketCap: 0,\n            sectorStrength: 0,\n            correlationSPY: 0,\n            avgVolume: 0\n        };\n    }\n}\n\n// Export for use in React components\nexport default MLTradingSystem;\n"],"names":["isBrowser","window","constructor","this","model","version","accuracy","confidence","trainingData","patterns","Map","strategies","performance","features","technical","sentiment","market","tradeHistory","activeTrades","recommendations","loadModel","initializeNeuralNetwork","network","inputLayer","hiddenLayers","outputLayer","weights","initializeWeights","learningRate","ih","Array","fill","map","Math","random","hh1","hh2","ho","savedModel","localStorage","getItem","parsed","JSON","parse","_objectSpread","console","log","e","savedHistory","saveModel","modelToSave","from","entries","setItem","stringify","extractFeatures","data","push","calculateRSI","prices","calculateMACD","calculateBollingerBands","vwap","normalizeVolume","volume","calculateVolatility","calculateTrend","calculateMomentum","callVolume","putVolume","unusualActivity","socialSentiment","newsSentiment","marketCap","sectorStrength","correlationSPY","f","isNaN","predict","current","activate","matrixMultiply","output","softmax","buyStrong","buy","hold","sell","sellStrong","max","train","tradeData","marketData","actualOutcome","encodeOutcome","result","outcome","timestamp","Date","now","symbol","strategy","length","slice","backpropagate","updatePatterns","updateStrategyPerformance","updateModelAccuracy","totalTrades","target","prediction","error","calculateError","Object","keys","forEach","layer","row","w","pattern","identifyPattern","has","type","set","occurrences","successRate","totalReturn","patternStats","get","profit","percentReturn","isGoldenCross","isBullFlag","isCupAndHandle","isDeathCross","isBearFlag","isHeadAndShoulders","isTriangle","isRange","join","trades","wins","losses","avgReturn","winRate","sharpeRatio","stats","calculateSharpeRatio","generateRecommendations","options","arguments","undefined","symbols","symbolData","getMarketData","patternPerformance","action","determineAction","includeHold","expectedReturn","calculateExpectedReturn","risk","calculateRisk","patternSuccess","reasoning","generateReasoning","timeframe","entryPrice","currentPrice","stopLoss","calculateStopLoss","takeProfit","calculateTakeProfit","positionSize","calculatePositionSize","capital","sort","a","b","limit","recordTrade","trade","modelVersion","modelAccuracy","status","entryMarketData","holdingPeriod","exitTime","entryTime","filter","t","id","getPerformanceMetrics","modelConfidence","calculateWinRate","calculateAvgReturn","calculateOverallSharpe","maxDrawdown","calculateMaxDrawdown","profitFactor","calculateProfitFactor","_ref","name","_ref2","recentTrades","period","gains","i","diff","calculateEMA","multiplier","ema","sma","reduce","variance","sum","price","pow","stdDev","sqrt","returns","ret","n","indices","_","sumX","sumY","x","past","sma50","calculateSMA","sma200","recent","trend","consolidation","midPoint","floor","leftHigh","bottom","min","rightHigh","abs","third","leftShoulder","head","rightShoulder","highs","lows","highTrend","lowTrend","volatility","isArray","v","exp","vector","matrix","val","returnPercent","values","indexOf","atr","calculateATR","trueRanges","high","low","prevClose","tr","includes","reasons","concat","rsi","avgVolume","toFixed","correctPredictions","_trade$result","_t$result","_t$result2","peak","runningTotal","_trade$result2","drawdown"],"sourceRoot":""}